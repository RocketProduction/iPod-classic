<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>iPod Classic 5.5G</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        :root {
            --page-bg: #0a0a0a;
        }
        
        body {
            min-height: 100vh;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a0a; /* Corrisponde a theme_color del manifest */
            background: var(--page-bg);
            font-family: 'Podium Sans', 'Myriad Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            transition: background 0.5s ease;
        }
        
        body.light-bg {
            --page-bg: #e5e5e5;
        }
        
        .ipod {
            width: 280px;
            height: 460px;
            background: linear-gradient(180deg, #e8e8e8 0%, #d0d0d0 50%, #b8b8b8 100%);
            border-radius: 24px;
            padding: 20px;
            box-shadow: 
                0 0 0 1px rgba(255,255,255,0.4) inset,
                0 2px 4px rgba(0,0,0,0.1) inset,
                0 -2px 4px rgba(255,255,255,0.3) inset,
                0 25px 70px rgba(0,0,0,0.5),
                0 10px 25px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .ipod.black-theme {
            background: linear-gradient(180deg, #3a3a3a 0%, #1a1a1a 50%, #0a0a0a 100%);
        }
        
        .ipod::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.12) 0%, transparent 100%);
            border-radius: 24px 24px 0 0;
            pointer-events: none;
        }
        
        /* Schermo con ombra interna vetro */
        .screen-bezel {
            width: 100%;
            height: 175px;
            background: #1a1a1a;
            border-radius: 6px;
            padding: 6px;
            box-shadow: 
                0 3px 12px rgba(0,0,0,0.7) inset,
                0 1px 0 rgba(255,255,255,0.1),
                0 -1px 3px rgba(0,0,0,0.3) inset;
        }
        
        .screen {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #fff 0%, #f8f8f8 100%);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: 
                inset 0 0 8px rgba(0,0,0,0.08),
                inset 0 1px 2px rgba(0,0,0,0.05);
        }
        
        /* Effetto vetro bombato con riflesso luce */
        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: -20%;
            width: 60%;
            height: 100%;
            background: linear-gradient(
                105deg,
                rgba(255,255,255,0.6) 0%,
                rgba(255,255,255,0.3) 40%,
                rgba(255,255,255,0.1) 50%,
                transparent 60%
            );
            pointer-events: none;
            z-index: 999;
        }
        
        /* Header */
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 8px;
            background: linear-gradient(180deg, #c8c8c8 0%, #a8a8a8 100%);
            border-bottom: 1px solid #888;
            font-size: 11px;
            font-weight: 600;
            color: #000;
            height: 20px;
            min-height: 20px;
            max-height: 20px;
            overflow: hidden;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 30px;
            flex-shrink: 0;
        }
        
        .header-center {
            flex: 1;
            text-align: center;
            font-weight: bold;
            overflow: hidden;
            min-width: 0;
        }
        
        .header-center .title-text {
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            min-width: 30px;
            flex-shrink: 0;
        }
        
        .play-status {
            color: #2196F3;
            font-size: 10px;
        }
        
        .battery {
            display: flex;
            align-items: center;
        }
        
        .battery-icon {
            width: 22px;
            height: 10px;
            border: 1.5px solid #000;
            border-radius: 2px;
            position: relative;
            display: flex;
            align-items: center;
            padding: 1px;
        }
        
        .battery-icon::after {
            content: '';
            position: absolute;
            right: -4px;
            width: 2px;
            height: 5px;
            background: #000;
            border-radius: 0 1px 1px 0;
        }
        
        .battery-level {
            height: 100%;
            width: 85%;
            background: linear-gradient(180deg, #4cd964 0%, #2ecc40 100%);
            border-radius: 1px;
        }
        
        /* Contenuto schermo */
        .screen-content {
            height: calc(100% - 22px);
            overflow: hidden;
            position: relative;
            background: #fff;
        }
        
        /* Views con transizioni slide */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            background: #fff;
        }
        
        .view.active {
            display: flex;
        }
        
        /* Menu con scrollbar iPod */
        .menu-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }

        .menu-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .menu-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .menu-list::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .menu-list:hover::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.3);
        }
        
        .menu-list {
            scrollbar-width: thin;
            scrollbar-color: rgba(0,0,0,0.2) transparent;
        }
        
        .menu-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 8px 3px 5px;
            font-size: 11px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            min-height: 15px;
        }
        
        .menu-item.selected {
            background: linear-gradient(180deg, #4a9eff 0%, #1e6fdd 100%);
            color: white;
        }
        
        .menu-item .arrow {
            font-size: 12px;
            font-weight: 300;
            opacity: 0.5;
        }
        
        .menu-item.selected .arrow {
            opacity: 1;
        }

        /* Song item con artista */
        .song-item-content {
            flex: 1;
            min-width: 0;
        }
        
        .song-item-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: bold;
            line-height: 1.2;
        }
        
        .song-item-artist {
            font-size: 8px;
            font-weight: bold;
            opacity: 0.6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.1;
        }
        
        .menu-item.selected .song-item-artist {
            opacity: 0.8;
        }
        
        /* Now Playing - Layout originale iPod */
        .nowplaying-view {
            padding: 0;
            /* Sfondo bianco come i menu */
            background: #ffffff;
            flex-direction: column;
            height: 100%;
        }
        
        .nowplaying-view.active {
            display: flex;
        }
        
        /* Contatore tracce e icone status */
        .np-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px 0 12px;
        }
        
        .np-header {
            font-size: 11px;
            font-weight: 600;
            color: #1a1a1a;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        
        .np-status-icons {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        
        .status-icon {
            width: 14px;
            height: 14px;
            display: inline-block;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        .icon-shuffle {
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23333' d='M8.7,14.2C8,14.7,7.1,15,6.2,15H4c-0.6,0-1,0.4-1,1s0.4,1,1,1h2.2c1.3,0,2.6-0.4,3.7-1.2c0.4-0.3,0.5-1,0.2-1.4C9.7,13.9,9.1,13.8,8.7,14.2z'/%3E%3Cpath fill='%23333' d='M13,10.7c0.3,0,0.6-0.1,0.8-0.3C14.5,9.5,15.6,9,16.8,9h0.8l-0.3,0.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l2-2c0.1-0.1,0.2-0.2,0.2-0.3c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-2-2c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4L17.6,7h-0.8c-1.8,0-3.4,0.8-4.6,2.1c-0.4,0.4-0.3,1,0.1,1.4C12.5,10.7,12.8,10.7,13,10.7z'/%3E%3Cpath fill='%23333' d='M20.7,15.3l-2-2c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l0.3,0.3h-1.5c-1.6,0-2.9-0.9-3.6-2.3l-1.2-2.4C10.3,8.3,8.2,7,5.9,7H4C3.4,7,3,7.4,3,8s0.4,1,1,1h1.9c1.6,0,2.9,0.9,3.6,2.3l1.2,2.4c1,2.1,3.1,3.4,5.4,3.4h1.5l-0.3,0.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l2-2C21.1,16.3,21.1,15.7,20.7,15.3z'/%3E%3C/svg%3E");
        }
        
        .icon-repeat {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256'%3E%3Cpath fill='%23333' d='M180.4,29.3v15.4L131.3,45c-48.7,0.2-49.2,0.2-54.6,1.4c-7.9,1.8-12.8,3.5-20.3,7.1c-8.6,4.2-15.1,8.9-22.2,15.9C27.2,76.5,22.6,83,18.4,91.6c-3.7,7.6-5.4,12.5-7.1,20.5c-1,4.8-1.3,7.4-1.3,15.9c0,9.1,0.2,10.7,1.5,16.7c0.8,3.6,2.3,8.6,3.3,11.1l1.7,4.5L27,149.7l10.6-10.5l-0.9-2.7c-1.2-3.9-0.7-15.8,0.9-22.2c5.3-20.6,20.4-35.8,41.5-41.6l4.7-1.3l48.3-0.2l48.3-0.2v15.5V102l22-22.1l22.1-22l-22.1-22l-22-22.1L180.4,29.3L180.4,29.3z'/%3E%3Cpath fill='%23333' d='M228.6,105.8l-10.1,10.1l-0.1,10.8c-0.1,9.5-0.2,11.5-1.3,15.5c-5.4,20-20.8,35.4-40.9,40.9l-5.4,1.5l-47.7,0.2L75.3,185v-15.5V154l-22,22.1l-22.1,22l22.1,22l22,22.1v-15.4v-15.4l49.1-0.2c48.1-0.2,49.2-0.2,54.3-1.4c11.8-2.7,23-7.6,32-13.8c6.3-4.5,15.4-13.6,19.9-19.9c4-5.7,9.2-16.1,11.3-22.4c5.6-17.6,5.3-36-0.9-53c-1-2.6-1.9-4.8-2.1-4.8C238.8,95.7,234.2,100.3,228.6,105.8z'/%3E%3C/svg%3E");
        }
        
        .icon-repeat-one {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath fill='%23333' d='M8,28H8a2,2,0,0,0,2-2V22a8,8,0,0,1,8-8h0l16,0h0v3a1,1,0,0,0,1,1,1,1,0,0,0,.65-.26h0l6-5h0a1,1,0,0,0,0-1.44h0l-6-5h0A1,1,0,0,0,35,6a1,1,0,0,0-1,1v3h0L18,10h0A12,12,0,0,0,6,22v4A2,2,0,0,0,8,28Z'/%3E%3Cpath fill='%23333' d='M40,20h0a2,2,0,0,0-2,2v4a8,8,0,0,1-8,8h0L14,34h0V31a1,1,0,0,0-1-1,1,1,0,0,0-.65.26h0l-6,5h0a1,1,0,0,0,0,1.44h0l6,5h0A1,1,0,0,0,13,42a1,1,0,0,0,1-1V38h0l16,0h0A12,12,0,0,0,42,26V22A2,2,0,0,0,40,20Z'/%3E%3Cpolygon fill='%23333' points='28 30 28 18 27 18 24 18 23 18 19 24 23 24 24 22.5 24 30 28 30'/%3E%3C/svg%3E");
        }
        
        /* Area centrale con cover e metadata */
        .np-main {
            display: flex;
            gap: 15px;
            padding: 8px 12px;
            flex: 1;
            align-items: center;
        }
        
        .album-art-wrapper {
            position: relative;
            width: 72px;
            height: 72px;
            flex-shrink: 0;
        }
        
        .album-art {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);
            border-radius: 2px;
            /* Ombra tipica iPod Classic */
            box-shadow: 
                2px 3px 8px rgba(0,0,0,0.35),
                0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .album-art .no-art {
            font-size: 28px;
            color: #999;
        }
        
        .album-art .loading-art {
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        /* Equalizzatore - 7 barre controllate da Web Audio API */
        .equalizer {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            height: 16px;
            align-items: flex-end;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .equalizer.active {
            opacity: 1;
        }
        
        .eq-bar {
            width: 3px;
            height: 3px;
            background: rgba(255,255,255,0.9);
            border-radius: 1px;
            transform-origin: bottom;
            transition: height 0.06s linear;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Info canzone a destra della cover */
        .np-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
        }
        
        .np-title {
            font-size: 14px;
            font-weight: 700;
            color: #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.3;
        }

        /* Marquee titolo */
        .np-title .marquee-text {
            display: inline-block;
            white-space: nowrap;
            transform: translateX(0);
        }

        .np-title.marquee {
            text-overflow: clip;
        }

        .np-title.marquee .marquee-text {
            padding-right: 22px;
            animation: titleMarquee var(--marquee-duration, 8s) linear infinite;
            will-change: transform;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        @keyframes titleMarquee {
            0%, 15% { transform: translateX(0); }
            50%, 65% { transform: translateX(calc(-1 * var(--marquee-distance, 0px))); }
            100% { transform: translateX(0); }
        }
        
        .np-artist {
            font-size: 13px;
            font-weight: 400;
            color: #222;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.3;
        }
        
        .np-album {
            font-size: 13px;
            font-weight: 400;
            color: #444;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.3;
        }
        
        /* Progress bar container - in basso con margini */
        .progress-container {
            padding: 0 15px 12px 15px;
            margin-top: auto;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: linear-gradient(180deg, 
                #d0d0d0 0%, 
                #e8e8e8 20%, 
                #f5f5f5 50%, 
                #ffffff 80%, 
                #e0e0e0 100%
            );
            border-radius: 0;
            overflow: hidden;
            box-shadow: 
                inset 0 1px 3px rgba(0,0,0,0.2),
                inset 0 -1px 1px rgba(255,255,255,0.8),
                0 1px 0 rgba(255,255,255,0.5);
            cursor: pointer;
            position: relative;
            border: 1px solid #a0a0a0;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            position: relative;
            pointer-events: none;
            border-radius: 0;
            /* Base blue with vertical stripes texture */
            background: 
                /* Glossy top highlight - sharp cut at 50% */
                linear-gradient(180deg,
                    rgba(255,255,255,0.6) 0%,
                    rgba(255,255,255,0.4) 45%,
                    rgba(255,255,255,0.0) 50%,
                    rgba(0,0,0,0.1) 50%,
                    rgba(0,0,0,0.15) 100%
                ),
                /* Vertical ribbed texture */
                repeating-linear-gradient(
                    90deg,
                    rgba(255,255,255,0.15) 0px,
                    rgba(255,255,255,0.15) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                /* Base blue gradient */
                linear-gradient(180deg,
                    #5eb3ff 0%,
                    #3d9eff 40%,
                    #2d7bfd 50%,
                    #1e6ae8 60%,
                    #1a5fd0 100%
                );
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.4),
                inset 0 -1px 0 rgba(0,0,0,0.2);
        }
        /* Scrub mode feedback (Now Playing clickwheel scrub) */
        .nowplaying-view.scrub-active .progress-fill {
            /* Keep the same texture/gloss, but switch to a mercury-red fill */
            background:
                /* Glossy top highlight - sharp cut at 50% */
                linear-gradient(180deg,
                    rgba(255,255,255,0.6) 0%,
                    rgba(255,255,255,0.4) 45%,
                    rgba(255,255,255,0.0) 50%,
                    rgba(0,0,0,0.1) 50%,
                    rgba(0,0,0,0.15) 100%
                ),
                /* Vertical ribbed texture */
                repeating-linear-gradient(
                    90deg,
                    rgba(255,255,255,0.15) 0px,
                    rgba(255,255,255,0.15) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                /* Mercury-red base gradient */
                linear-gradient(180deg,
                    #ff7b7b 0%,
                    #ff4d4d 40%,
                    #e80000 50%,
                    #c60000 60%,
                    #9a0000 100%
                );
        }

        /* Keep the old scrubber element hidden (no dot indicator) */
        .progress-scrubber { display: none !important; }


        
        /* Scrub position indicator (only in Now Playing scrub mode) */
        .progress-scrubber {
            display: none; /* hidden by default */
            position: absolute;
            top: 50%;
            left: 100%; /* end of the filled portion */
            width: 7px;
            height: 7px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            /* "mercury red" dot */
            background: radial-gradient(circle at 30% 30%, #ffb3b3 0%, #d30000 40%, #7a0000 100%);
            box-shadow:
                0 1px 0 rgba(255,255,255,0.6),
                inset 0 1px 1px rgba(255,255,255,0.35),
                inset 0 -1px 1px rgba(0,0,0,0.35);
        }

        .nowplaying-view.scrub-active .progress-scrubber {
            display: block;
        }
        
        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #000;
            margin-top: 4px;
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            letter-spacing: -0.3px;
        }
        
        /* Cover Flow */
        .coverflow-view {
            background: linear-gradient(180deg, #2a2a2a 0%, #0a0a0a 100%);
            flex-direction: column;
            overflow: hidden;
        }
        
        .coverflow-view.active {
            display: flex;
        }
        
        .coverflow-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 600px;
            overflow: visible;
            position: relative;
            cursor: grab;
            padding-top: 15px;
            padding-bottom: 72px;
        }
        
        .coverflow-container:active {
            cursor: grabbing;
        }
        
        .coverflow-track {
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .coverflow-item {
            position: absolute;
            width: 65px;
            height: 65px;
            transform-style: preserve-3d;
            cursor: pointer;
            will-change: transform, opacity;
            /* Transizione fluida per tutte le proprietà */
            transition: transform 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), 
                        opacity 0.4s ease,
                        box-shadow 0.4s ease;
            /* Riflesso sotto le copertine */
            -webkit-box-reflect: below 2px linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 60%, rgba(255,255,255,0.15) 100%);
        }
        
        .coverflow-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 2px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
            background: #000;
            transition: border 0.3s ease, box-shadow 0.3s ease;
        }
        
        .coverflow-item .no-art-cf {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #444 0%, #222 100%);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: #666;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            transition: border 0.3s ease, box-shadow 0.3s ease;
        }
        
        .coverflow-item.center img,
        .coverflow-item.center .no-art-cf {
            border: 2px solid rgba(255,255,255,0.9);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5), 0 0 15px rgba(33, 150, 243, 0.3);
        }
        
        .coverflow-info {
			position: absolute;
			left: 0;
			right: 0;
			bottom: 10px;
			text-align: center;
			padding: 4px 20px;
			min-height: 44px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-end;
			pointer-events: none;
			}
				
        .coverflow-title-wrapper {
			width: 100%;
			height: 18px; /* Altezza esplicita per contenere il testo */
			overflow: hidden;
			position: relative;
			display: flex;
			justify-content: center;
			align-items: center;
		}
        
        .coverflow-title {
			font-size: 12px; /* Leggermente più grande */
			font-weight: 600;
			color: #fff;
			white-space: nowrap;
			line-height: 1.4; /* Aggiunto per evitare il ritaglio verticale */
			display: inline-block;
			vertical-align: middle;
		}
        
        
        .coverflow-title.scrolling {
            animation: cfMarquee var(--cf-scroll-duration, 8s) linear infinite;
            will-change: transform;
        }
        
        .coverflow-title-wrapper.scrolling {
            justify-content: flex-start;
            padding-left: 8px;
            padding-right: 8px;
        }
        
        @keyframes cfMarquee {
            0%, 15% { transform: translateX(0); }
            40%, 60% { transform: translateX(var(--cf-scroll-offset, -50px)); }
            85%, 100% { transform: translateX(0); }
        }
        
        .coverflow-artist {
			font-size: 10px;
			color: #aaa;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			margin-top: 1px;
			line-height: 1.2;
			min-height: 12px;
		}
        
        /* Lyrics View */
        .lyrics-view {
            background: #fff;
        }
        
        .lyrics-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 11px;
            line-height: 1.6;
            color: #333;
            text-align: center;
        }
        
        .lyrics-content.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
        }
        
        .lyrics-content.error {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-style: italic;
        }
        
        .lyrics-text {
            padding-bottom: 20px;
        }
        
        /* Karaoke / Synced Lyrics Styles */
        .lyrics-synced {
            padding: 40px 5px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .lyric-line {
            font-size: 12px;
            line-height: 1.5;
            color: #888;
            transition: all 0.3s ease;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .lyric-line.past {
            color: #aaa;
        }
        
        .lyric-line.active {
            color: #000;
            font-weight: 600;
            font-size: 13px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }
        
        .lyrics-content .loading,
        .lyrics-content .error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
        }
        
        .lyrics-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333;
            font-size: 12px;
            gap: 15px;
            padding: 20px;
        }
        
        /* Apple Rainbow Beach Ball Spinner - Centered */
        .lyrics-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding-top: 20px;
        }
        
        .lyrics-spinner {
            display: block;
            width: 22px !important;
            height: 22px !important;
            min-width: 22px;
            min-height: 22px;
            max-width: 22px;
            max-height: 22px;
            flex-shrink: 0;
            flex-grow: 0;
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            position: relative;
            animation: apple-spin 0.8s linear infinite;
            background: conic-gradient(
                from 0deg,
                #ff3b30 0deg,
                #ff9500 51deg,
                #ffcc00 102deg,
                #34c759 153deg,
                #5ac8fa 204deg,
                #007aff 255deg,
                #af52de 306deg,
                #ff3b30 360deg
            );
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        @keyframes apple-spin {
            to { transform: rotate(360deg); }
        }
        
        .lyrics-progress-bar {
            display: none;
        }
        
        .lyrics-progress-fill {
            display: none;
        }
        
        .lyrics-status {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-top: 12px;
        }
        
        /* Click Wheel con riflesso migliorato */
        .clickwheel-container {
            margin-top: 18px;
            display: flex;
            justify-content: center;
        }
        
        .clickwheel {
            touch-action: none;
            cursor: pointer;
            width: 190px;
            height: 190px;
            background: linear-gradient(145deg, #f5f5f5 0%, #e0e0e0 50%, #ccc 100%);
            border-radius: 50%;
            position: relative;
            box-shadow: 
                0 1px 2px rgba(0,0,0,0.1),
                0 4px 8px rgba(0,0,0,0.15),
                0 8px 16px rgba(0,0,0,0.1),
                0 -2px 4px rgba(255,255,255,0.6) inset,
                0 4px 12px rgba(0,0,0,0.15) inset;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
		
		.screen::after {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.05) 100%);
			pointer-events: none; /* Importante: non deve bloccare i click */
			z-index: 10;
		}
        
        .ipod.black-theme .clickwheel {
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 50%, #0a0a0a 100%);
        }
        
        /* Riflesso circolare sulla wheel */
        .clickwheel::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 15%;
            right: 15%;
            height: 40%;
            background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0.05) 50%, transparent 100%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            pointer-events: none;
        }
        
        .ipod.black-theme .clickwheel::before {
            background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.02) 50%, transparent 100%);
        }
        
        .center-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 65px;
            height: 65px;
            background: linear-gradient(145deg, #fff 0%, #eee 50%, #ddd 100%);
            border-radius: 50%;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.2),
                0 4px 8px rgba(0,0,0,0.1),
                0 -2px 3px rgba(255,255,255,0.9) inset,
                0 2px 4px rgba(0,0,0,0.1) inset;
            cursor: pointer;
            z-index: 10;
            -webkit-tap-highlight-color: transparent;
			touch-action: manipulation;
            -webkit-touch-callout: none;
        }
        
        .ipod.black-theme .center-button {
            background: linear-gradient(145deg, #333 0%, #222 50%, #111 100%);
        }
        
        .center-button:active {
            transform: translate(-50%, -50%) scale(0.96);
        }
        
        /* Labels sulla wheel */
        .wheel-label {
            position: absolute;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            pointer-events: none;
        }
        
        .ipod.black-theme .wheel-label {
            color: #888;
        }
        
        .wheel-label.menu {
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 9px;
        }
        
        .wheel-label.prev {
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
        }
        
        .wheel-label.next {
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
        }
        
        .wheel-label.playpause {
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
        }
        
        .wheel-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .wheel-indicator.active {
            opacity: 1;
        }
        
        .wheel-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #2196F3;
            border-radius: 50%;
            transform: translateX(-50%);
        }
        
        /* Overlays */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid #ddd;
            border-top-color: #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-text {
            margin-top: 10px;
            font-size: 11px;
            color: #333;
        }
        
        .loading-progress {
            margin-top: 4px;
            font-size: 10px;
            color: #666;
        }
        
        .volume-overlay {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 6px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 50;
        }
        
        .volume-overlay.active {
            display: flex;
        }
        
        .volume-icon {
            font-size: 12px;
            color: white;
        }
        
        .volume-bar {
            width: 70px;
            height: 5px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .volume-fill {
            height: 100%;
            background: #fff;
            border-radius: 3px;
        }
        
        .drop-zone {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(33, 150, 243, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            color: white;
            font-size: 12px;
            font-weight: 600;
            border-radius: 3px;
        }
        
        .drop-zone.active {
            display: flex;
        }
        
        /* Toast Notification */
        .toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 300;
            white-space: nowrap;
        }
        
        .toast.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        /* Confirm Modal */
        .confirm-modal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 250;
        }
        
        .confirm-modal.active {
            display: flex;
        }
        
        .confirm-box {
            background: linear-gradient(180deg, #f8f8f8 0%, #e8e8e8 100%);
            border-radius: 8px;
            padding: 16px;
            width: 85%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        .confirm-title {
            font-size: 12px;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
        }
        
        .confirm-message {
            font-size: 11px;
            color: #555;
            margin-bottom: 14px;
            line-height: 1.4;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .confirm-btn {
            padding: 6px 18px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid #999;
            transition: all 0.2s;
        }
        
        .confirm-btn.cancel {
            background: linear-gradient(180deg, #fff 0%, #ddd 100%);
            color: #333;
        }
        
        .confirm-btn.danger {
            background: linear-gradient(180deg, #ff6b6b 0%, #e53935 100%);
            color: white;
            border-color: #c62828;
        }
        
        .confirm-btn:hover {
            transform: scale(1.05);
        }
        
        /* EQ Editor - iPod Style */
        .eq-editor {
            display: flex;
            flex-direction: column;
            padding: 0;
            gap: 0;
            height: 100%;
            background: #fff;
            overflow-y: auto;
        }
        
        .eq-header {
            font-size: 10px;
            color: #666;
            padding: 6px 10px 4px;
            background: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }
        
        .eq-band {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: transparent;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .eq-band.selected {
            background: linear-gradient(180deg, #4a9eff 0%, #1e6fdd 100%);
        }
        
        .eq-band.editing {
            background: linear-gradient(180deg, #ff9e4a 0%, #dd6f1e 100%);
            animation: pulse-edit 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse-edit {
            from { opacity: 1; }
            to { opacity: 0.85; }
        }
        
        .eq-type {
            font-size: 10px;
            width: 28px;
            color: #333;
            font-weight: 600;
        }
        
        .eq-band.selected .eq-type {
            color: #fff;
        }
        
        .eq-val {
            font-size: 10px;
            width: 42px;
            color: #333;
            text-align: right;
        }
        
        .eq-band.selected .eq-val {
            color: #fff;
        }
        
        .eq-slider-track {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .eq-slider-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #1e6fdd);
            border-radius: 3px;
            transition: width 0.1s, left 0.1s;
        }
        
        .eq-band.selected .eq-slider-track {
            background: rgba(255,255,255,0.3);
        }
        
        .eq-band.selected .eq-slider-fill {
            background: #fff;
        }
        
        .eq-freq {
            font-size: 9px;
            width: 44px;
            color: #666;
            text-align: right;
        }
        
        .eq-band.selected .eq-freq {
            color: rgba(255,255,255,0.9);
        }
        
        .eq-q {
            font-size: 9px;
            width: 20px;
            color: #999;
            text-align: right;
        }
        
        .eq-band.selected .eq-q {
            color: rgba(255,255,255,0.7);
        }
        
        /* Virtual Keyboard */
        .keyboard-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #fff;
        }
        
        .keyboard-input {
            padding: 8px 10px;
            background: #f5f5f5;
            border-bottom: 1px solid #ccc;
        }
        
        .keyboard-input-text {
            font-size: 14px;
            color: #000;
            min-height: 20px;
            padding: 4px 6px;
            background: #fff;
            border: 1px solid #bbb;
            border-radius: 4px;
        }
        
        .keyboard-input-cursor {
            display: inline-block;
            width: 2px;
            height: 14px;
            background: #007aff;
            animation: blink 1s infinite;
            vertical-align: middle;
            margin-left: 1px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .keyboard-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            padding: 6px;
            overflow-y: auto;
        }
        
        .keyboard-key {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 26px;
            background: #e8e8e8;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            color: #333;
        }
        
        .keyboard-key.selected {
            background: linear-gradient(180deg, #4a9eff 0%, #1e6fdd 100%);
            color: #fff;
        }
        
        .keyboard-key.wide {
            grid-column: span 2;
        }
        
        .keyboard-key.action {
            background: #d0d0d0;
            font-size: 10px;
        }
        
        .keyboard-key.action.selected {
            background: linear-gradient(180deg, #4a9eff 0%, #1e6fdd 100%);
        }
        
        .file-input {
            display: none;
        }
    /* ===== PWA fullscreen / portrait layout hardening ===== */
html, body {
    width: 100%;
    height: 100%;
}
body {
    padding-top: env(safe-area-inset-top);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
}
/* Scale the whole iPod to fill available width while preserving aspect ratio */
.ipod {
    transform-origin: center center;
    transform: scale(var(--pwa-scale, 1));
    will-change: transform;
}
/* Landscape guard */
#portraitOnlyOverlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    text-align: center;
    background: #000;
    color: #fff;
    z-index: 999999;
    padding: 24px;
    font-size: 16px;
    line-height: 1.35;
}

/* Scrub mode: change progress fill color (no thumb) */
.progress-bar.scrub-active .progress-fill {
    background: #b1001a; /* mercury red */
}
</style>
    <!-- PWA -->
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
</head>
<body>
    <!-- EMERGENCY: Force iPod visibility in PWA standalone mode -->
    <script>
    (function() {
        'use strict';
        // This runs IMMEDIATELY when body starts parsing
        // It ensures the iPod is visible even if other JS fails
        
        function forceShowiPod() {
            var ipod = document.getElementById('ipod');
            var overlay = document.getElementById('portraitOnlyOverlay');
            if (ipod) {
                ipod.style.display = '';
                ipod.style.visibility = 'visible';
                ipod.style.opacity = '1';
                console.log('[PWA-INIT] iPod forced visible');
            }
            // Only show portrait overlay in landscape ON MOBILE DEVICES
            if (overlay) {
                var isLandscape = window.innerWidth > window.innerHeight;
                var isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                               ('ontouchstart' in window && window.innerWidth < 1024);
                overlay.style.display = (isLandscape && isMobile) ? 'flex' : 'none';
            }
        }
        
        // Run as soon as possible
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', forceShowiPod);
        } else {
            forceShowiPod();
        }
        
        // Also run after delays as failsafe
        setTimeout(forceShowiPod, 100);
        setTimeout(forceShowiPod, 500);
        setTimeout(forceShowiPod, 1000);
        setTimeout(forceShowiPod, 2000);
        
        // Log for debugging
        console.log('[PWA-INIT] Emergency visibility script loaded');
    })();
    </script>

    <div id="portraitOnlyOverlay">Ruota il dispositivo in verticale (portrait) per usare il player.</div>

    <div class="ipod" id="ipod">
        <div class="screen-bezel">
            <div class="screen">
                <div class="screen-header">
                    <div class="header-left">
                        <span class="play-status" id="playStatus"></span>
                    </div>
                    <div class="header-center">
                        <span class="title-text" id="headerTitle">iPod</span>
                    </div>
                    <div class="header-right">
                        <div class="battery">
                            <div class="battery-icon">
                                <div class="battery-level"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="screen-content">
                    <!-- Menu View -->
                    <div class="view active" id="menuView">
                        <div class="menu-list" id="menuList">
                            <div class="menu-item selected" data-action="music">
                                <span>Music</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="coverflow">
                                <span>Cover Flow</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="shuffle">
                                <span>Shuffle Songs</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="nowplaying">
                                <span>Now Playing</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="load">
                                <span>Add Music...</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="loadFolder">
                                <span>Add Folder...</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="settings">
                                <span>Settings</span>
                                <span class="arrow">›</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Songs View (All Songs) -->
                    <div class="view" id="songsView">
                        <div class="menu-list" id="songsList"></div>
                    </div>
                    
                    <!-- Music Menu View -->
                    <div class="view" id="musicMenuView">
                        <div class="menu-list" id="musicMenuList">
                            <div class="menu-item selected" data-action="allsongs">
                                <span>Songs</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="artists">
                                <span>Artists</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="albums">
                                <span>Albums</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="playlists">
                                <span>Playlists</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="queue">
                                <span>Queue</span>
                                <span class="arrow">›</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Playlists View -->
                    <div class="view" id="playlistsView">
                        <div class="menu-list" id="playlistsList"></div>
                    </div>
                    
                    <!-- Single Playlist View -->
                    <div class="view" id="playlistView">
                        <div class="menu-list" id="playlistSongsList"></div>
                    </div>
                    
                    <!-- Add to Playlist View -->
                    <div class="view" id="addToPlaylistView">
                        <div class="menu-list" id="addToPlaylistList"></div>
                    </div>
                    
                    <!-- Virtual Keyboard View (for playlist renaming) -->
                    <div class="view" id="keyboardView">
                        <div class="keyboard-view">
                            <div class="keyboard-input">
                                <div class="keyboard-input-text" id="keyboardText"><span class="keyboard-input-cursor"></span></div>
                            </div>
                            <div class="keyboard-grid" id="keyboardGrid"></div>
                        </div>
                    </div>
                    
                    <!-- Artists View -->
                    <div class="view" id="artistsView">
                        <div class="menu-list" id="artistsList"></div>
                    </div>
                    
                    <!-- Artist's Albums View -->
                    <div class="view" id="artistAlbumsView">
                        <div class="menu-list" id="artistAlbumsList"></div>
                    </div>
                    
                    <!-- Albums View -->
                    <div class="view" id="albumsView">
                        <div class="menu-list" id="albumsList"></div>
                    </div>
                    
                    <!-- Album Songs View -->
                    <div class="view" id="albumSongsView">
                        <div class="menu-list" id="albumSongsList"></div>
                    </div>
                    
                    <!-- Queue View -->
                    <div class="view" id="queueView">
                        <div class="menu-list" id="queueList"></div>
                    </div>
                    
                    <!-- Settings View -->
                    <div class="view" id="settingsView">
                        <div class="menu-list" id="settingsList">
                            <div class="menu-item selected" data-action="repeat">
                                <span>Repeat</span>
                                <span id="repeatValue">Off</span>
                            </div>
                            <div class="menu-item" data-action="shuffleToggle">
                                <span>Shuffle</span>
                                <span id="shuffleValue">Off</span>
                            </div>
                            <div class="menu-item" data-action="eq">
                                <span>EQ</span>
                                <span id="eqValue">Flat</span>
                            </div>
                            <div class="menu-item" data-action="crossfade">
                                <span>Crossfade</span>
                                <span id="crossfadeValue">Off</span>
                            </div>
                            <div class="menu-item" data-action="gapless">
                                <span>Gapless</span>
                                <span id="gaplessValue">On</span>
                            </div>
                            <div class="menu-item" data-action="replayGain">
                                <span>Replay Gain</span>
                                <span id="replayGainValue">Off</span>
                            </div>
                            <div class="menu-item" data-action="clickSound">
                                <span>Click Sound</span>
                                <span id="clickSoundValue">On</span>
                            </div>
                            <div class="menu-item" data-action="hapticFeedback">
                                <span>Haptic Feedback</span>
                                <span id="hapticValue">On</span>
                            </div>
                            <div class="menu-item" data-action="theme">
                                <span>Theme</span>
                                <span id="themeValue">White</span>
                            </div>
                            <div class="menu-item" data-action="clearQueue">
                                <span>Clear Queue</span>
                                <span class="arrow">›</span>
                            </div>
                            <div class="menu-item" data-action="clearAll">
                                <span>Clear All Songs</span>
                                <span class="arrow">›</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- EQ Profiles View -->
                    <div class="view" id="eqView">
                        <div class="menu-list" id="eqList"></div>
                    </div>
                    
                    <!-- EQ Edit View (per profili custom) - Parametric EQ -->
                    <div class="view" id="eqEditView">
                        <div class="eq-editor" id="eqEditor">
                            <div class="eq-header">Edit Mode: Gain (dB)</div>
                            <div class="eq-band selected" data-band="0">
                                <span class="eq-type">LS:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">32Hz</span>
                                <span class="eq-q">0.7</span>
                            </div>
                            <div class="eq-band" data-band="1">
                                <span class="eq-type">PK1:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">64Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="2">
                                <span class="eq-type">PK2:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">125Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="3">
                                <span class="eq-type">PK3:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">250Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="4">
                                <span class="eq-type">PK4:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">500Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="5">
                                <span class="eq-type">PK5:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">1000Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="6">
                                <span class="eq-type">PK6:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">2000Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="7">
                                <span class="eq-type">PK7:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">4000Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="8">
                                <span class="eq-type">PK8:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">8000Hz</span>
                                <span class="eq-q">1.0</span>
                            </div>
                            <div class="eq-band" data-band="9">
                                <span class="eq-type">HS:</span>
                                <span class="eq-val">0.0dB</span>
                                <div class="eq-slider-track"><div class="eq-slider-fill"></div></div>
                                <span class="eq-freq">16000Hz</span>
                                <span class="eq-q">0.7</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Now Playing View -->
                    <div class="view nowplaying-view" id="nowPlayingView">
                        <div class="np-top-bar">
                            <div class="np-header" id="npHeader">0 of 0</div>
                            <div class="np-status-icons" id="npStatusIcons"></div>
                        </div>
                        <div class="np-main">
                            <div class="album-art-wrapper">
                                <div class="album-art" id="albumArt">
                                    <span class="no-art">♫</span>
                                </div>
                                <div class="equalizer" id="equalizer">
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                    <div class="eq-bar"></div>
                                </div>
                            </div>
                            <div class="np-info">
                                <div class="np-title" id="trackTitle">
                                    <span class="marquee-text" id="trackTitleText">No Song</span>
                                </div>
                                <div class="np-artist" id="trackArtist"></div>
                                <div class="np-album" id="trackAlbum"></div>
                            </div>
                        </div>
                        <div class="progress-container">
                            <div class="progress-bar" id="progressBar">
                                <div class="progress-fill" id="progressFill">
                                    <div class="progress-scrubber" id="progressScrubber"></div>
                                </div>
                            </div>
                            <div class="time-display">
                                <span id="currentTime">0:00</span>
                                <span id="remainingTime">-0:00</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Cover Flow View -->
                    <div class="view coverflow-view" id="coverflowView">
                        <div class="coverflow-container" id="coverflowContainer">
                        <div class="coverflow-track" id="coverflowTrack"></div>

                        <div class="coverflow-info coverflow-info-under">
                            <div class="coverflow-title-wrapper" id="cfTitleWrapper">
                                <span class="coverflow-title" id="cfTitle">No Songs</span>
                            </div>
                    <div class="coverflow-artist" id="cfArtist"></div>
                        </div>
                            </div>
                    </div>
                    
                    <!-- Lyrics View -->
                    <div class="view lyrics-view" id="lyricsView">
                        <div class="lyrics-content" id="lyricsContent">
                            Loading lyrics...
                        </div>
                    </div>
                </div>
                
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="loadingText">Loading...</div>
                    <div class="loading-progress" id="loadingProgress"></div>
                </div>
                
                <div class="volume-overlay" id="volumeOverlay">
                    <span class="volume-icon">🔊</span>
                    <div class="volume-bar">
                        <div class="volume-fill" id="volumeFill" style="width: 70%"></div>
                    </div>
                </div>
                
                <div class="drop-zone" id="dropZone">Drop MP3 files here</div>
                
                <div class="toast" id="toast"></div>
                
                <div class="confirm-modal" id="confirmModal">
                    <div class="confirm-box">
                        <div class="confirm-title" id="confirmTitle">Confirm</div>
                        <div class="confirm-message" id="confirmMessage">Are you sure?</div>
                        <div class="confirm-buttons">
                            <button class="confirm-btn cancel" id="confirmCancel">Cancel</button>
                            <button class="confirm-btn danger" id="confirmOk">Delete</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="clickwheel-container">
            <div class="clickwheel" id="clickwheel">
                <div class="wheel-indicator" id="wheelIndicator"></div>
                <span class="wheel-label menu">MENU</span>
                <span class="wheel-label prev">◀◀</span>
                <span class="wheel-label next">▶▶</span>
                <span class="wheel-label playpause">▶ ❚❚</span>
                <div class="center-button" id="centerButton"></div>
            </div>
        </div>
    </div>
    
    <input type="file" class="file-input" id="fileInput" accept="audio/*,.mp3,.m4a,.wav,.ogg,.flac" multiple>
    <input type="file" class="file-input" id="folderInput" webkitdirectory directory multiple>

    <script>
        // ===== CRITICAL: Set up fallback BEFORE anything else =====
        // This ensures app works even if jsmediatags CDN fails
        console.log('[iPod] Script block 1 starting...');
        
        window.jsmediatags = {
            read: function(file, callbacks) {
                // Basic fallback - just call onError so app continues
                setTimeout(function() {
                    if (callbacks && callbacks.onError) {
                        callbacks.onError({ type: 'fallback', info: 'jsmediatags not available' });
                    }
                }, 10);
            }
        };
        
        // Global error handler to prevent app from freezing
        window.onerror = function(msg, url, line, col, error) {
            console.error('[iPod] Global error:', msg, 'at', url, line, col);
            // Force show iPod on any error
            try {
                var ipod = document.getElementById('ipod');
                if (ipod) { ipod.style.display = ''; ipod.style.visibility = 'visible'; }
            } catch(e) {}
            return true; // Prevent error from stopping execution
        };
        window.addEventListener('unhandledrejection', function(e) {
            console.error('[iPod] Unhandled promise rejection:', e.reason);
            e.preventDefault(); // Prevent unhandled rejection from stopping execution
        });
        
        console.log('[iPod] Script block 1 complete');
    </script>
    
    <!-- Load jsmediatags async - won't block if it fails -->
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    
    <script>
        console.log('[iPod] Main script starting...');
        
        // ==================== AUDIO ====================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        let audioReady = false;
        
        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => { audioReady = true; }).catch(() => {});
            } else {
                audioReady = true;
            }
        }
        
        // Initialize audio on first user interaction (click/touch) 
        // so wheel scrolling can play sounds immediately
        function warmUpAudio() {
            initAudio();
            document.removeEventListener('click', warmUpAudio);
            document.removeEventListener('touchstart', warmUpAudio);
            document.removeEventListener('keydown', warmUpAudio);
        }
        document.addEventListener('click', warmUpAudio);
        document.addEventListener('touchstart', warmUpAudio);
        document.addEventListener('keydown', warmUpAudio);
        
        function playClick(freq = 1200, dur = 0.015, vol = 0.08) {
            if (typeof state !== 'undefined' && !state.clickSound) return;
            if (!audioCtx || audioCtx.state === 'suspended') {
                initAudio();
                return; // Skip this tick, audio will work on next interaction
            }
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }
        
        // --- HAPTICS (Chrome/Android) ---

        function safeVibrate(pattern) {
            try {
                if (typeof state === 'undefined' || !state.hapticFeedback) return false;
                if (!navigator || typeof navigator.vibrate !== 'function') return false;
                return navigator.vibrate(pattern);
            } catch (e) { 
                return false; 
            }
        }

        // Throttle for tick haptics only (wheel rotation)
        let _lastTickHaptic = 0;
        
        function tickSound() { 
            if (typeof state !== 'undefined' && state.clickSound) {
                playClick(2200, 0.008, 0.04);
            }
            // Tick haptics: short pulse for each wheel tick
            const now = performance.now();
            if (now - _lastTickHaptic > 80) {
                _lastTickHaptic = now;
                safeVibrate(20);
            }
        }
        function selectSound() { 
            if (typeof state !== 'undefined' && state.clickSound) {
                playClick(1000, 0.04, 0.12);
            }
            // Select haptics: stronger pulse on select
            safeVibrate(50);
        }

        // ==================== STATE ====================
        const state = {
            view: 'menu',
            menuIdx: 0,
            musicMenuIdx: 0,
            songIdx: 0,
            artistIdx: 0,
            artistAlbumsIdx: 0,
            albumIdx: 0,
            albumSongsIdx: 0,
            playlistsIdx: 0,
            playlistIdx: 0,
            addToPlaylistIdx: 0,
            queueIdx: 0,
            settingsIdx: 0,
            cfIdx: 0,
            cfTargetIdx: 0,
            eqIdx: 0,
            eqEditIdx: 0,
            eqEditMode: false, // true when adjusting a band value
            eqProfile: 'flat',
            songs: [],
            filteredSongs: [],
            filterType: null,
            filterValue: null,
            currentArtist: null, // Currently selected artist for navigation
            currentAlbum: null,  // Currently selected album for navigation
            playlists: [],
            currentPlaylist: null,
            currentSong: -1,
            playing: false,
            volume: 0.7,
            repeat: 'off',
            shuffle: false,
            theme: 'white',
            history: ['menu'],
            shuffleQueue: [],
            shufflePos: 0,
            lyrics: {},
            currentCustomEQ: null,
            // Album-based CoverFlow
            albumsCF: [], // Array of {artist, album, artwork, songIndices[]}
            // Keyboard state
            keyboardIdx: 0,
            keyboardText: '',
            keyboardTitle: '',
            keyboardCallback: null,
            // Playback features
            queue: [],
            crossfade: 0,
            gapless: true,
            replayGain: false,
            // Playback context - tracks what list we're playing from
            playbackContext: 'all', // 'all', 'playlist', 'album', 'artist', 'queue'
            playbackList: [], // The actual list of song indices being played
            playbackIdx: 0, // Current position in playbackList
            // Feedback settings
            clickSound: true,
            hapticFeedback: true,
            showWheelIndicator: false,
            // Lyrics tracking
            lyricsLoadingFor: -1,
            lyricsRequestId: 0,
            // Now Playing scrubbing (clickwheel)
            npScrubActive: false,
            npScrubTarget: 0,
            npScrubWasPlaying: false,
            npScrubLastMoveTs: 0,
            npScrubMoved: false,
            npScrubEnterTs: 0
        };
        
        // Parametric EQ - 10 bands: LS, PK1-8, HS
        // Each band has: gain, freq, Q, type
        const defaultEQBands = [
            { type: 'lowshelf', gain: 0, freq: 32, Q: 0.7 },
            { type: 'peaking', gain: 0, freq: 64, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 125, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 250, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 500, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 1000, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 2000, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 4000, Q: 1.0 },
            { type: 'peaking', gain: 0, freq: 8000, Q: 1.0 },
            { type: 'highshelf', gain: 0, freq: 16000, Q: 0.7 }
        ];
        
        // Profili Equalizzatore - 10 bande
        const eqProfiles = {
            flat: { name: 'Flat', bands: JSON.parse(JSON.stringify(defaultEQBands)) },
            rock: { name: 'Rock', bands: [
                { type: 'lowshelf', gain: 4, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: 3, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: -1, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: 3, freq: 16000, Q: 0.7 }
            ]},
            pop: { name: 'Pop', bands: [
                { type: 'lowshelf', gain: -1, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: 1, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: -1, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: -1, freq: 16000, Q: 0.7 }
            ]},
            jazz: { name: 'Jazz', bands: [
                { type: 'lowshelf', gain: 3, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: 2, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: -1, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: 2, freq: 16000, Q: 0.7 }
            ]},
            classical: { name: 'Classical', bands: [
                { type: 'lowshelf', gain: 4, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: 3, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: 3, freq: 16000, Q: 0.7 }
            ]},
            bass: { name: 'Bass Boost', bands: [
                { type: 'lowshelf', gain: 6, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: 5, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: 0, freq: 16000, Q: 0.7 }
            ]},
            vocal: { name: 'Vocal', bands: [
                { type: 'lowshelf', gain: -2, freq: 32, Q: 0.7 },
                { type: 'peaking', gain: -1, freq: 64, Q: 1.0 },
                { type: 'peaking', gain: 0, freq: 125, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 250, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 500, Q: 1.0 },
                { type: 'peaking', gain: 4, freq: 1000, Q: 1.0 },
                { type: 'peaking', gain: 3, freq: 2000, Q: 1.0 },
                { type: 'peaking', gain: 2, freq: 4000, Q: 1.0 },
                { type: 'peaking', gain: 1, freq: 8000, Q: 1.0 },
                { type: 'highshelf', gain: 0, freq: 16000, Q: 0.7 }
            ]},
            custom1: { name: 'Custom 1', bands: JSON.parse(JSON.stringify(defaultEQBands)) },
            custom2: { name: 'Custom 2', bands: JSON.parse(JSON.stringify(defaultEQBands)) },
            custom3: { name: 'Custom 3', bands: JSON.parse(JSON.stringify(defaultEQBands)) }
        };

        // Carica stato da localStorage
        function loadState() {
            try {
                const saved = localStorage.getItem('ipod-classic-state');
                if (saved) {
                    const data = JSON.parse(saved);
                    state.volume = data.volume ?? 0.7;
                    state.repeat = data.repeat ?? 'off';
                    state.shuffle = data.shuffle ?? false;
                    // Migrate silver -> white
                    state.theme = data.theme === 'silver' ? 'white' : (data.theme ?? 'white');
                    state.eqProfile = data.eqProfile ?? 'flat';
                    state.playlists = data.playlists ?? [];
                    state.crossfade = data.crossfade ?? 0;
                    state.gapless = data.gapless ?? true;
                    state.replayGain = data.replayGain ?? false;
                    state.clickSound = data.clickSound ?? true;
                    state.hapticFeedback = data.hapticFeedback ?? true;
                    state.showWheelIndicator = data.showWheelIndicator ?? false;
                }
                // Carica EQ custom
                const eqSaved = localStorage.getItem('ipod-custom-eq-v2');
                if (eqSaved) {
                    const eqData = JSON.parse(eqSaved);
                    if (eqData.custom1) eqProfiles.custom1.bands = eqData.custom1;
                    if (eqData.custom2) eqProfiles.custom2.bands = eqData.custom2;
                    if (eqData.custom3) eqProfiles.custom3.bands = eqData.custom3;
                }
            } catch (e) { console.log('Load state error:', e); }
        }
        
        function saveState() {
            try {
                const data = JSON.stringify({
                    volume: state.volume,
                    repeat: state.repeat,
                    shuffle: state.shuffle,
                    theme: state.theme,
                    eqProfile: state.eqProfile,
                    playlists: state.playlists,
                    crossfade: state.crossfade,
                    gapless: state.gapless,
                    replayGain: state.replayGain,
                    clickSound: state.clickSound,
                    hapticFeedback: state.hapticFeedback,
                    showWheelIndicator: state.showWheelIndicator
                });
                localStorage.setItem('ipod-classic-state', data);
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn('localStorage quota exceeded, trying to save minimal state');
                    // Try saving without playlists
                    try {
                        localStorage.setItem('ipod-classic-state', JSON.stringify({
                            volume: state.volume,
                            repeat: state.repeat,
                            shuffle: state.shuffle,
                            theme: state.theme,
                            eqProfile: state.eqProfile,
                            crossfade: state.crossfade,
                            gapless: state.gapless,
                            replayGain: state.replayGain,
                            clickSound: state.clickSound,
                            hapticFeedback: state.hapticFeedback,
                            showWheelIndicator: state.showWheelIndicator
                        }));
                    } catch (e2) {
                        console.error('Cannot save state:', e2);
                    }
                }
            }
        }
        
        function saveCustomEQ() {
            try {
                localStorage.setItem('ipod-custom-eq-v2', JSON.stringify({
                    custom1: eqProfiles.custom1.bands,
                    custom2: eqProfiles.custom2.bands,
                    custom3: eqProfiles.custom3.bands
                }));
            } catch (e) {}
        }

        // Primary and secondary audio elements for crossfade
        const audio = new Audio();
        const audio2 = new Audio();
        // Audio attributes for better PWA behavior on Android
        audio.preload = 'auto';
        audio2.preload = 'auto';
        audio.crossOrigin = 'anonymous';
        audio2.crossOrigin = 'anonymous';
        // Prevent audio ducking/interruption on Android
        audio.preservesPitch = true;
        audio2.preservesPitch = true;
        // Set audio category hints for mobile browsers
        if ('audioSession' in navigator) {
            try { navigator.audioSession.type = 'playback'; } catch (e) {}
        }
        let activeAudio = audio;
        let inactiveAudio = audio2;
        let crossfadeTimer = null;
        let gaplessPreloaded = false;
        
        // MediaSession position update on metadata load
        function onLoadedMetadataForMediaSession(e) {
            const a = e.target;
            // Only update if this is the active audio and duration is valid
            if (a === activeAudio && a.duration && isFinite(a.duration) && a.duration > 0) {
                try {
                    if (navigator.mediaSession && navigator.mediaSession.setPositionState) {
                        navigator.mediaSession.setPositionState({
                            duration: a.duration,
                            playbackRate: a.playbackRate || 1,
                            position: Math.max(0, Math.min(a.currentTime || 0, a.duration))
                        });
                    }
                } catch (e) {}
            }
        }
        audio.addEventListener('loadedmetadata', onLoadedMetadataForMediaSession);
        audio2.addEventListener('loadedmetadata', onLoadedMetadataForMediaSession);
        
        // Also update on canplay for better Android support
        function onCanPlayForMediaSession(e) {
            const a = e.target;
            if (a === activeAudio && a.duration && isFinite(a.duration) && a.duration > 0) {
                try {
                    if (navigator.mediaSession && navigator.mediaSession.setPositionState) {
                        navigator.mediaSession.setPositionState({
                            duration: a.duration,
                            playbackRate: a.playbackRate || 1,
                            position: Math.max(0, Math.min(a.currentTime || 0, a.duration))
                        });
                    }
                } catch (e) {}
            }
        }
        audio.addEventListener('canplay', onCanPlayForMediaSession);
        audio2.addEventListener('canplay', onCanPlayForMediaSession);
        
        // Update MediaSession when playback actually starts
        function onPlayingForMediaSession(e) {
            const a = e.target;
            if (a === activeAudio && a.duration && isFinite(a.duration) && a.duration > 0) {
                try {
                    if (navigator.mediaSession && navigator.mediaSession.setPositionState) {
                        navigator.mediaSession.setPositionState({
                            duration: a.duration,
                            playbackRate: a.playbackRate || 1,
                            position: Math.max(0, Math.min(a.currentTime || 0, a.duration))
                        });
                    }
                } catch (e) {}
            }
        }
        audio.addEventListener('playing', onPlayingForMediaSession);
        audio2.addEventListener('playing', onPlayingForMediaSession);
        
        // ==================== ELEMENTS ====================
        const $ = id => document.getElementById(id);
        const el = {
            ipod: $('ipod'),
            menuView: $('menuView'),
            songsView: $('songsView'),
            musicMenuView: $('musicMenuView'),
            artistsView: $('artistsView'),
            artistAlbumsView: $('artistAlbumsView'),
            albumsView: $('albumsView'),
            albumSongsView: $('albumSongsView'),
            playlistsView: $('playlistsView'),
            playlistView: $('playlistView'),
            addToPlaylistView: $('addToPlaylistView'),
            keyboardView: $('keyboardView'),
            queueView: $('queueView'),
            settingsView: $('settingsView'),
            eqView: $('eqView'),
            eqEditView: $('eqEditView'),
            nowPlayingView: $('nowPlayingView'),
            coverflowView: $('coverflowView'),
            lyricsView: $('lyricsView'),
            menuList: $('menuList'),
            songsList: $('songsList'),
            musicMenuList: $('musicMenuList'),
            artistsList: $('artistsList'),
            artistAlbumsList: $('artistAlbumsList'),
            albumsList: $('albumsList'),
            albumSongsList: $('albumSongsList'),
            playlistsList: $('playlistsList'),
            playlistSongsList: $('playlistSongsList'),
            addToPlaylistList: $('addToPlaylistList'),
            keyboardGrid: $('keyboardGrid'),
            keyboardText: $('keyboardText'),
            queueList: $('queueList'),
            settingsList: $('settingsList'),
            eqList: $('eqList'),
            eqEditor: $('eqEditor'),
            headerTitle: $('headerTitle'),
            playStatus: $('playStatus'),
            npHeader: $('npHeader'),
            npStatusIcons: $('npStatusIcons'),
            albumArt: $('albumArt'),
            equalizer: $('equalizer'),
            trackTitle: $('trackTitle'),
            trackTitleText: $('trackTitleText'),
            trackArtist: $('trackArtist'),
            trackAlbum: $('trackAlbum'),
            progressBar: $('progressBar'),
            progressFill: $('progressFill'),
            progressScrubber: $('progressScrubber'),
            currentTime: $('currentTime'),
            remainingTime: $('remainingTime'),
            coverflowTrack: $('coverflowTrack'),
            coverflowContainer: $('coverflowContainer'),
            cfTitleWrapper: $('cfTitleWrapper'),
            cfTitle: $('cfTitle'),
            cfArtist: $('cfArtist'),
            lyricsContent: $('lyricsContent'),
            loadingOverlay: $('loadingOverlay'),
            loadingText: $('loadingText'),
            loadingProgress: $('loadingProgress'),
            volumeOverlay: $('volumeOverlay'),
            volumeFill: $('volumeFill'),
            clickwheel: $('clickwheel'),
            centerButton: $('centerButton'),
            wheelIndicator: $('wheelIndicator'),
            fileInput: $('fileInput'),
            folderInput: $('folderInput'),
            dropZone: $('dropZone'),
            repeatValue: $('repeatValue'),
            shuffleValue: $('shuffleValue'),
            themeValue: $('themeValue'),
            eqValue: $('eqValue'),
            crossfadeValue: $('crossfadeValue'),
            gaplessValue: $('gaplessValue'),
            replayGainValue: $('replayGainValue'),
            clickSoundValue: $('clickSoundValue'),
            hapticValue: $('hapticValue'),
            toast: $('toast'),
            confirmModal: $('confirmModal'),
            confirmTitle: $('confirmTitle'),
            confirmMessage: $('confirmMessage'),
            confirmCancel: $('confirmCancel'),
            confirmOk: $('confirmOk')
        };
        
        // ==================== WEB AUDIO API ====================
        let audioAnalyser = null;
        let audioSource = null;
        let audioSource2 = null;
        let eqFilters = [];
        let analyserData = null;
        let eqAnimId = null;
        let webAudioReady = false;
        
        function setupAudioAnalyser() {
            if (webAudioReady || !audioCtx) return;
            
            try {
                audioAnalyser = audioCtx.createAnalyser();
                audioAnalyser.fftSize = 64;
                audioAnalyser.smoothingTimeConstant = 0.7;
                analyserData = new Uint8Array(audioAnalyser.frequencyBinCount);
                
                // Only create media source once per audio element lifetime
                if (!audioSource) {
                    audioSource = audioCtx.createMediaElementSource(audio);
                }
                if (!audioSource2) {
                    audioSource2 = audioCtx.createMediaElementSource(audio2);
                }
                
                // Crea 10 filtri EQ parametrici
                if (eqFilters.length === 0) {
                    const profile = eqProfiles[state.eqProfile] || eqProfiles.flat;
                    profile.bands.forEach((band, i) => {
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = band.type;
                        filter.frequency.value = band.freq;
                        filter.Q.value = band.Q;
                        filter.gain.value = band.gain;
                        eqFilters.push(filter);
                    });
                }
                
                // Catena: source -> filters -> analyser -> destination
                audioSource.connect(eqFilters[0]);
                if (audioSource2) audioSource2.connect(eqFilters[0]);
                for (let i = 0; i < eqFilters.length - 1; i++) {
                    eqFilters[i].connect(eqFilters[i + 1]);
                }
                eqFilters[eqFilters.length - 1].connect(audioAnalyser);
                audioAnalyser.connect(audioCtx.destination);
                
                // Applica profilo attuale
                applyEQProfile(state.eqProfile);
                webAudioReady = true;
                console.log('Web Audio API ready with 10-band parametric EQ');
            } catch (e) {
                console.log('Web Audio setup error:', e);
                try {
                    if (audioSource) {
                        audioSource.connect(audioCtx.destination);
                    }
                    if (audioSource2) {
                        audioSource2.connect(audioCtx.destination);
                    }
                    webAudioReady = true;
                } catch (e2) {
                    console.log('Fallback also failed:', e2);
                }
            }
        }
        
        // Preview EQ senza salvare (per scroll)
        let eqPreviewWarningShown = false;
        function previewEQProfile(key) {
            const profile = eqProfiles[key];
            if (!profile || !profile.bands) return;
            
            if (eqFilters.length === 0) {
                if (audioCtx && !webAudioReady) {
                    setupAudioAnalyser();
                }
                if (eqFilters.length === 0) {
                    if (!eqPreviewWarningShown) {
                        showToast('Play a song to hear EQ preview');
                        eqPreviewWarningShown = true;
                    }
                    return;
                }
            }
            
            profile.bands.forEach((band, i) => {
                if (eqFilters[i]) {
                    eqFilters[i].gain.value = band.gain;
                    eqFilters[i].frequency.value = band.freq;
                    eqFilters[i].Q.value = band.Q;
                }
            });
        }
        
        // Applica e salva EQ (per select)
        function applyEQProfile(key) {
            const profile = eqProfiles[key];
            if (!profile || !profile.bands) return;
            
            profile.bands.forEach((band, i) => {
                if (eqFilters[i]) {
                    eqFilters[i].gain.value = band.gain;
                    eqFilters[i].frequency.value = band.freq;
                    eqFilters[i].Q.value = band.Q;
                    eqFilters[i].type = band.type;
                }
            });
            state.eqProfile = key;
            saveState();
        }
        
        function updateVisualEQ() {
            // Don't animate if not in nowplaying view (save CPU)
            if (!audioAnalyser || !state.playing || state.view !== 'nowplaying') {
                stopVisualEQ();
                return;
            }
            
            try {
                audioAnalyser.getByteFrequencyData(analyserData);
                const bars = el.equalizer.querySelectorAll('.eq-bar');
                const bands = [1, 3, 5, 8, 11, 14, 17];
                
                bars.forEach((bar, i) => {
                    const val = analyserData[bands[i]] || 0;
                    bar.style.height = Math.max(3, (val / 255) * 16) + 'px';
                });
            } catch (e) {}
            
            eqAnimId = requestAnimationFrame(updateVisualEQ);
        }
        
        function startVisualEQ() {
            if (!audioCtx) initAudio();
            if (!webAudioReady) setupAudioAnalyser();
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            cancelAnimationFrame(eqAnimId);
            updateVisualEQ();
        }
        
        function stopVisualEQ() {
            cancelAnimationFrame(eqAnimId);
            const bars = el.equalizer.querySelectorAll('.eq-bar');
            bars.forEach(bar => bar.style.height = '3px');
        }

        // ==================== CLICK WHEEL ====================
        let wheel = { active: false, lastAngle: 0, accum: 0, moved: false };
        
        // Hold per seek
        let holdTimer = null;
        let holdInterval = null;
        let holdZone = null;
        
        function getClientXY(e) {
            if (e && e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            if (e && e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function getWheelMetrics() {
            const rect = el.clickwheel.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const r = Math.min(rect.width, rect.height) / 2;
            // Scale thresholds from the original 190px wheel (radius 95px)
            const centerR = r * 0.36;   // ~35/95
            const outerR = r * 0.98;    // keep a small edge margin
            return { rect, cx, cy, r, centerR, outerR };
        }

        function getAngle(e) {
            const { cx, cy } = getWheelMetrics();
            const { x, y } = getClientXY(e);
            return Math.atan2(y - cy, x - cx);
        }

        function getDistance(e) {
            const { cx, cy } = getWheelMetrics();
            const { x, y } = getClientXY(e);
            return Math.hypot(x - cx, y - cy);
        }

        function getZone(e) {
            const { cx, cy, centerR, outerR } = getWheelMetrics();
            const { x, y } = getClientXY(e);
            const dist = Math.hypot(x - cx, y - cy);

            if (dist < centerR) return 'center';
            if (dist > outerR) return 'outside';

            const angle = Math.atan2(y - cy, x - cx) * 180 / Math.PI;
            if (angle > -45 && angle <= 45) return 'next';
            if (angle > 45 && angle <= 135) return 'playpause';
            if (angle > -135 && angle <= -45) return 'menu';
            return 'prev';
        }

        function clearHold() {
            if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
            if (holdInterval) { clearInterval(holdInterval); holdInterval = null; }
            holdZone = null;
        }
        
        

        // Ghost-click guard: touch interactions can generate synthetic mouse events on some devices.
        // This prevents clickwheel actions from firing twice on hybrid input stacks.
        let _ignoreMouseUntilTs = 0;
        function markTouchGesture() {
            _ignoreMouseUntilTs = performance.now() + 900;
        }
        function isMouseAfterTouch(e) {
            if (!e || !e.type) return false;
            if (e.type === 'mousedown' || e.type === 'mousemove' || e.type === 'mouseup') {
                return performance.now() < _ignoreMouseUntilTs;
            }
            return false;
        }

        function wheelStart(e) {
            // Center button must not cancel the synthetic click on mobile browsers.
            if (e && el.centerButton && el.centerButton.contains(e.target)) return;
            if (isMouseAfterTouch(e)) return;
            if (e && (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel')) {
                markTouchGesture();
                if (e.type === 'touchstart' && e.cancelable) e.preventDefault();
            }

            
            const dist = getDistance(e);
            const { centerR, outerR } = getWheelMetrics();
            if (dist > centerR && dist < outerR) {
                initAudio();
                wheel.active = true;
                wheel.moved = false;
                wheel.lastAngle = getAngle(e);
                wheel.accum = 0;
                if (state.showWheelIndicator) {
                    el.wheelIndicator.classList.add('active');
                }
                
                // Start hold timer per prev/next
                const zone = getZone(e);
                if (zone === 'prev' || zone === 'next') {
                    holdZone = zone;
                    holdTimer = setTimeout(() => {
                        if (state.currentSong >= 0 && activeAudio.duration) {
                            if (crossfadeActive) cancelCrossfade();
                            holdInterval = setInterval(() => {
                                const delta = holdZone === 'next' ? 2 : -2;
                                activeAudio.currentTime = Math.max(0, Math.min(activeAudio.duration, activeAudio.currentTime + delta));
                            }, 100);
                        }
                    }, 500);
                }
                // 3. Long press on MENU button for delete
                else if (zone === 'menu') {
                    holdZone = zone;
                    holdTimer = setTimeout(() => {
                        handleMenuLongPress();
                    }, 800);
                }
            }
        }
        
        function wheelMove(e) {
            if (!wheel.active) return;
            if (isMouseAfterTouch(e)) return;
            if (e && (e.type === 'touchmove' || e.type === 'touchstart')) {
                markTouchGesture();
                if (e.cancelable) e.preventDefault();
            }
            
            const angle = getAngle(e);
            let delta = angle - wheel.lastAngle;
            
            if (delta > Math.PI) delta -= 2 * Math.PI;
            if (delta < -Math.PI) delta += 2 * Math.PI;
            
            // Non-linear acceleration (iPod-like): faster rotation scrolls faster
            const velocity = Math.abs(delta);
            if (velocity < 0.003) { wheel.lastAngle = angle; return; } // jitter guard
            const acceleration = velocity > 0.15 ? 3.2 : (velocity > 0.08 ? 1.7 : 1.0);

            wheel.accum += delta * acceleration;
            wheel.lastAngle = angle;

            // Mark as moved (prevents accidental 'click' on small rotations)
            if (Math.abs(wheel.accum) > 0.10) {
                wheel.moved = true;
                clearHold();
            }

            const threshold = 0.35; // higher threshold reduces touch jitter
            const steps = Math.floor(Math.abs(wheel.accum) / threshold);
            if (steps > 0) {
                wheel.moved = true;
                clearHold(); // Cancel hold if there's movement
                const dir = wheel.accum > 0 ? 1 : -1;
                // Apply multiple scroll steps in one move for acceleration effect
                for (let i = 0; i < steps; i++) {
                    const didScroll = scroll(dir);
                    if (didScroll) tickSound();
                }
                wheel.accum -= dir * steps * threshold;
            }

            if (state.showWheelIndicator) {
                el.wheelIndicator.style.transform = `translate(-50%, -50%) rotate(${wheel.accum * 180 / Math.PI}deg)`;
            }
        }
        
        function wheelEnd(e) {
            if (isMouseAfterTouch(e)) return;
            if (e && (e.type === 'touchend' || e.type === 'touchcancel')) {
                markTouchGesture();
                if (wheel.active && e.cancelable) e.preventDefault();
            }
            const wasActive = wheel.active;
            const wasMoved = wheel.moved;
            const wasHolding = holdInterval !== null;
            
            clearHold();
            wheel.active = false;
            if (state.showWheelIndicator) {
                el.wheelIndicator.classList.remove('active');
                el.wheelIndicator.style.transform = 'translate(-50%, -50%) rotate(0deg)';
            }
            
            // Se non c'è stato movimento e non era un hold, è un click
            if (wasActive && !wasMoved && !wasHolding && e) {
                const zone = getZone(e);
                initAudio();
                selectSound();
                
                const now = Date.now();

                if (zone === 'center') {
                    if (now - lastCenterSelectAt >= 250) {
                        lastCenterSelectAt = now;
                        handleSelect();
                    }
                    return;
                }

                switch (zone) {
                    case 'menu': goBack(); break;
                    case 'playpause': togglePlay(); break;
                    case 'prev': 
                        if (state.view === 'eqEdit') {
                            adjustEQBand(-1);
                        } else if (state.view === 'keyboard') {
                            scrollKeyboard(-7); // Jump one row
                        } else {
                            prevTrack();
                        }
                        break;
                    case 'next': 
                        if (state.view === 'eqEdit') {
                            adjustEQBand(1);
                        } else if (state.view === 'keyboard') {
                            scrollKeyboard(7); // Jump one row
                        } else {
                            nextTrack();
                        }
                        break;
                }
            }
        }
        
        el.clickwheel.addEventListener('mousedown', wheelStart);
        el.clickwheel.addEventListener('touchstart', wheelStart, { passive: false });
        document.addEventListener('mousemove', wheelMove);
        document.addEventListener('touchmove', wheelMove, { passive: false });
        document.addEventListener('mouseup', wheelEnd);
        document.addEventListener('touchend', wheelEnd);
        
        // Long press support for adding to queue
        let longPressTimer = null;
        let longPressTriggered = false;
        
        
        let lastCenterSelectAt = 0; // dedupe center select across touch/click paths
        let centerTouchStarted = false;
        
        function startLongPress(e) {
            if (e.type === 'touchstart') centerTouchStarted = true;
            longPressTriggered = false;
            longPressTimer = setTimeout(() => {
                longPressTriggered = true;
                handleLongPress();
            }, 800); // 800ms for long press
        }
        
        function cancelLongPress(e) {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            
            // Handle touchend as click for better responsiveness
            if (e && e.type === 'touchend' && centerTouchStarted && !longPressTriggered) {
                centerTouchStarted = false;
                const now = Date.now();
                if (now - lastCenterSelectAt < 200) return; // Dedupe
                lastCenterSelectAt = now;
                
                e.preventDefault();
                initAudio();
                selectSound();
                handleSelect();
            }
            centerTouchStarted = false;
        }
        
        function handleLongPress() {
            centerTouchStarted = false;
            // Add current selected song to queue
            if (state.view === 'songs') {
                const songsToUse = state.filteredSongs.length > 0 ? state.filteredSongs : state.songs;
                if (songsToUse.length > 0) {
                    const song = songsToUse[state.songIdx];
                    const realIdx = state.songs.indexOf(song);
                    if (realIdx >= 0) {
                        addToQueue(realIdx);
                    }
                }
            } else if (state.view === 'playlist' && state.playlistIdx >= 3) {
                const playlist = state.playlists[state.currentPlaylist];
                if (playlist) {
                    const pos = state.playlistIdx - 3;
                    const songIdx = playlist.songs[pos];
                    if (songIdx !== undefined) {
                        addToQueue(songIdx);
                    }
                }
            } else if (state.view === 'eq') {
                // Long press to enter edit mode for the preset
                const items = el.eqList.querySelectorAll('.menu-item');
                state.eqIdx = clampIndex(state.eqIdx, items.length);
                const key = items[state.eqIdx].dataset.profile;
                
                applyEQProfile(key);
                state.currentCustomEQ = key;
                state.eqEditIdx = 0;
                state.eqEditMode = false; // Start in navigation mode
                pushHistory('eqEdit');
                updateEQEditor();
                showView('eqEdit', 'forward');
            }
        }
        
        el.centerButton.addEventListener('mousedown', startLongPress);
        el.centerButton.addEventListener('touchstart', startLongPress, { passive: false });
        el.centerButton.addEventListener('mouseup', cancelLongPress);
        el.centerButton.addEventListener('touchend', cancelLongPress, { passive: false });
        el.centerButton.addEventListener('mouseleave', cancelLongPress);
        
        el.centerButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (longPressTriggered) {
                longPressTriggered = false;
                return; // Don't trigger normal click after long press
            }
            const now = Date.now();
            if (now - lastCenterSelectAt < 200) return; // Dedupe with touch
            lastCenterSelectAt = now;
            
            initAudio();
            selectSound();
            handleSelect();
        });

        // ==================== MOUSE WHEEL ====================
        let lastWheel = 0;
        el.ipod.addEventListener('wheel', (e) => {
            e.preventDefault();
            const now = Date.now();
            if (now - lastWheel < 80) return;
            lastWheel = now;
            initAudio();
            const didScroll = scroll(e.deltaY > 0 ? 1 : -1, true); // true = fromMouseWheel
            if (didScroll) tickSound();
        }, { passive: false });

        // ==================== SCROLL ====================
        // Returns true if scroll actually happened, false if at boundary
        function scroll(dir, fromMouseWheel = false) {
            let list, items, idxKey;
            
            if (state.view === 'menu') {
                list = el.menuList; items = list.querySelectorAll('.menu-item'); idxKey = 'menuIdx';
            } else if (state.view === 'musicMenu') {
                list = el.musicMenuList; items = list.querySelectorAll('.menu-item'); idxKey = 'musicMenuIdx';
            } else if (state.view === 'songs') {
                list = el.songsList; items = list.querySelectorAll('.menu-item'); idxKey = 'songIdx';
            } else if (state.view === 'artists') {
                list = el.artistsList; items = list.querySelectorAll('.menu-item'); idxKey = 'artistIdx';
            } else if (state.view === 'artistAlbums') {
                list = el.artistAlbumsList; items = list.querySelectorAll('.menu-item'); idxKey = 'artistAlbumsIdx';
            } else if (state.view === 'albums') {
                list = el.albumsList; items = list.querySelectorAll('.menu-item'); idxKey = 'albumIdx';
            } else if (state.view === 'albumSongs') {
                list = el.albumSongsList; items = list.querySelectorAll('.menu-item'); idxKey = 'albumSongsIdx';
            } else if (state.view === 'playlists') {
                list = el.playlistsList; items = list.querySelectorAll('.menu-item'); idxKey = 'playlistsIdx';
            } else if (state.view === 'playlist') {
                list = el.playlistSongsList; items = list.querySelectorAll('.menu-item'); idxKey = 'playlistIdx';
            } else if (state.view === 'addToPlaylist') {
                list = el.addToPlaylistList; items = list.querySelectorAll('.menu-item'); idxKey = 'addToPlaylistIdx';
            } else if (state.view === 'queue') {
                list = el.queueList; items = list.querySelectorAll('.menu-item'); idxKey = 'queueIdx';
            } else if (state.view === 'settings') {
                list = el.settingsList; items = list.querySelectorAll('.menu-item'); idxKey = 'settingsIdx';
            } else if (state.view === 'eq') {
                // EQ speciale: preview durante scroll
                const items = el.eqList.querySelectorAll('.menu-item'); 
                if (!items || items.length === 0) return false;
                
                // Safety check per indice
                if (state.eqIdx < 0) state.eqIdx = 0;
                if (state.eqIdx >= items.length) state.eqIdx = items.length - 1;
                
                // Check boundary
                const oldIdx = state.eqIdx;
                const newIdx = Math.max(0, Math.min(items.length - 1, state.eqIdx + dir));
                if (newIdx === oldIdx) return false;
                
                // Rimuovi selezione precedente
                items.forEach(item => item.classList.remove('selected'));
                
                state.eqIdx = newIdx;
                
                // Applica selezione
                items[state.eqIdx].classList.add('selected');
                items[state.eqIdx].scrollIntoView({ block: 'nearest' });
                
                // Applica preview audio in tempo reale (con debounce per evitare glitch)
                const keys = Object.keys(eqProfiles);
                if (keys[state.eqIdx]) {
                    clearTimeout(window._eqPreviewTimeout);
                    window._eqPreviewTimeout = setTimeout(() => {
                        previewEQProfile(keys[state.eqIdx]);
                    }, 80);
                }
                return true;
            } else if (state.view === 'eqEdit') {
                if (state.eqEditMode) {
                    // In edit mode: adjust the band value with clickwheel
                    adjustEQBand(dir * 0.5);
                    return true;
                } else {
                    // Navigation mode: move between bands
                    const bands = el.eqEditor.querySelectorAll('.eq-band');
                    if (!bands || bands.length === 0) return false;
                    
                    // Safety check
                    if (state.eqEditIdx < 0) state.eqEditIdx = 0;
                    if (state.eqEditIdx >= bands.length) state.eqEditIdx = bands.length - 1;
                    
                    // Check boundary
                    const oldIdx = state.eqEditIdx;
                    const newIdx = Math.max(0, Math.min(bands.length - 1, state.eqEditIdx + dir));
                    if (newIdx === oldIdx) return false;
                    
                    bands.forEach(b => b.classList.remove('selected', 'editing'));
                    state.eqEditIdx = newIdx;
                    bands[state.eqEditIdx].classList.add('selected');
                    bands[state.eqEditIdx].scrollIntoView({ block: 'nearest' });
                    return true;
                }
            } else if (state.view === 'coverflow') {
                if (state.albumsCF.length === 0) return false;
                // Smooth scroll: accumula il target e anima passo per passo
                const newTarget = Math.max(0, Math.min(state.albumsCF.length - 1, state.cfTargetIdx + dir));
                if (newTarget !== state.cfTargetIdx) {
                    state.cfTargetIdx = newTarget;
                    smoothScrollCF();
                    return true;
                }
                return false;
            } else if (state.view === 'nowplaying') {
                // Scrub mode: clickwheel adjusts track position
                if (state.npScrubActive) {
                    npAdjustScrub(dir);
                    return true;
                }
                // Invert direction for mouse wheel volume control (wheel up = volume up)
                const volDir = fromMouseWheel ? -dir : dir;
                // Check volume boundary
                const oldVol = state.volume;
                state.volume = Math.max(0, Math.min(1, state.volume + volDir * 0.05));
                if (state.volume === oldVol) return false;
                activeAudio.volume = state.volume;
                showVolume();
                saveState();
                return true;
            } else if (state.view === 'keyboard') {
                scrollKeyboard(dir);
                return true;
            } else if (state.view === 'lyrics') {
                el.lyricsContent.scrollTop += dir * 30;
                return true;
            }
            
            if (!items || !items.length) return false;
            
            // Check if we're at boundary
            const currentIdx = state[idxKey];
            const newIdx = Math.max(0, Math.min(items.length - 1, currentIdx + dir));
            
            // If index didn't change, we're at boundary - no feedback
            if (newIdx === currentIdx) return false;
            
            items[currentIdx].classList.remove('selected');
            state[idxKey] = newIdx;
            items[newIdx].classList.add('selected');
            items[newIdx].scrollIntoView({ block: 'nearest' });
            return true;
        }
        
        // Cover Flow smooth scroll - anima un passo alla volta
        let cfScrolling = false;
        function smoothScrollCF(targetIdx) {
            // If targetIdx provided, set it as target
            if (typeof targetIdx === 'number') {
                state.cfTargetIdx = Math.max(0, Math.min(state.albumsCF.length - 1, targetIdx));
            }
            
            if (cfScrolling) return; // Già in animazione
            if (state.cfIdx === state.cfTargetIdx) return; // Già al target
            
            cfScrolling = true;
            const step = state.cfIdx < state.cfTargetIdx ? 1 : -1;
            
            function animateStep() {
                state.cfIdx += step;
                updateCoverFlowPositions();
                
                if (state.cfIdx !== state.cfTargetIdx) {
                    // Continua l'animazione con delay per vedere ogni copertina
                    setTimeout(animateStep, 80); // 80ms tra ogni step
                } else {
                    cfScrolling = false;
                }
            }
            
            animateStep();
        }

        // ==================== VOLUME ====================
        let volTimeout;
        function showVolume() {
            el.volumeFill.style.width = (state.volume * 100) + '%';
            el.volumeOverlay.classList.add('active');
            clearTimeout(volTimeout);
            volTimeout = setTimeout(() => el.volumeOverlay.classList.remove('active'), 1500);
        }

        // ==================== NAVIGATION ====================
        function showView(name, direction = 'forward') {
            // If we leave Now Playing while scrubbing, clean up the scrub UI/state.
            if (state.view === 'nowplaying' && name !== 'nowplaying' && state.npScrubActive) {
                npExitScrubUI();
            }

            const views = { 
                menu: el.menuView, 
                musicMenu: el.musicMenuView,
                songs: el.songsView, 
                artists: el.artistsView,
                artistAlbums: el.artistAlbumsView,
                albums: el.albumsView,
                albumSongs: el.albumSongsView,
                playlists: el.playlistsView,
                playlist: el.playlistView,
                addToPlaylist: el.addToPlaylistView,
                keyboard: el.keyboardView,
                queue: el.queueView,
                settings: el.settingsView,
                eq: el.eqView,
                eqEdit: el.eqEditView,
                nowplaying: el.nowPlayingView,
                coverflow: el.coverflowView,
                lyrics: el.lyricsView
            };
            
            const nextView = views[name];
            
            if (!nextView) {
                console.log('View not found:', name);
                return;
            }
            
            // Stop EQ animation when leaving nowplaying (save CPU)
            if (state.view === 'nowplaying' && name !== 'nowplaying') {
                stopVisualEQ();
            }
            
            // Nascondi TUTTE le viste
            Object.values(views).forEach(v => {
                if (v) v.classList.remove('active');
            });
            
            // Mostra solo la nuova vista
            nextView.classList.add('active');
            
            // Aggiorna state
            state.view = name;
            
            // Ensure Cover Flow renders correctly when entering (e.g., returning from Now Playing).
            if (name === 'coverflow') {
                try {
                    if (typeof initCoverFlow === 'function' && typeof cfItems !== 'undefined' && cfItems.length === 0) {
                        initCoverFlow();
                    } else if (typeof updateCoverFlowPositions === 'function') {
                        updateCoverFlowPositions();
                    }
                    // Auto-fetch missing artworks in background
                    if (typeof fetchMissingCoverFlowArtworks === 'function') {
                        fetchMissingCoverFlowArtworks();
                    }
                } catch (e) {}
            }
            // Start EQ animation when entering nowplaying if playing
            if (name === 'nowplaying' && state.playing) {
                startVisualEQ();
            }
            
            // Aggiorna titolo header
            const titles = { 
                menu: 'iPod', 
                musicMenu: 'Music',
                songs: 'Songs', 
                artists: 'Artists',
                artistAlbums: state.currentArtist || 'Albums',
                albums: 'Albums',
                albumSongs: state.currentAlbum || 'Songs',
                playlists: 'Playlists',
                playlist: state.currentPlaylist !== null ? state.playlists[state.currentPlaylist]?.name : 'Playlist',
                addToPlaylist: 'Add to Playlist',
                keyboard: state.keyboardTitle || 'Enter Text',
                queue: 'Play Queue',
                settings: 'Settings',
                eq: 'EQ',
                eqEdit: state.currentCustomEQ ? eqProfiles[state.currentCustomEQ].name : 'Edit EQ',
                nowplaying: 'Now Playing',
                coverflow: 'Cover Flow',
                lyrics: 'Lyrics'
            };
            el.headerTitle.textContent = titles[name] || name;
            
            console.log('showView:', name, 'history:', [...state.history]);
        }
        
        // ==================== EQ FUNCTIONS ====================
        function updateEQList() {
            const keys = Object.keys(eqProfiles);
            el.eqList.innerHTML = keys.map((key, i) => {
                const profile = eqProfiles[key];
                const isActive = state.eqProfile === key;
                const isCustom = key.startsWith('custom');
                return `
                <div class="menu-item ${i === state.eqIdx ? 'selected' : ''}" data-profile="${key}">
                    <span>${isActive ? '✓ ' : ''}${profile.name}</span>
                    ${isCustom ? '<span class="arrow">›</span>' : ''}
                </div>
            `}).join('');
        }
        
        function updateEQEditor() {
            const profile = eqProfiles[state.currentCustomEQ];
            if (!profile || !profile.bands) return;
            
            // Update header based on mode
            const header = el.eqEditor.querySelector('.eq-header');
            if (header) {
                header.textContent = state.eqEditMode ? 
                    'Adjusting: Use wheel, click to confirm' : 
                    'Navigate: Use wheel, click to edit';
            }
            
            const bands = el.eqEditor.querySelectorAll('.eq-band');
            bands.forEach((band, i) => {
                if (!profile.bands[i]) return;
                
                band.classList.toggle('selected', i === state.eqEditIdx);
                band.classList.toggle('editing', i === state.eqEditIdx && state.eqEditMode);
                
                const bandData = profile.bands[i];
                const fill = band.querySelector('.eq-slider-fill');
                const valEl = band.querySelector('.eq-val');
                const freqEl = band.querySelector('.eq-freq');
                const qEl = band.querySelector('.eq-q');
                
                // Slider da -12 a +12 dB, centro a 50%
                const pct = ((bandData.gain + 12) / 24) * 100;
                if (bandData.gain >= 0) {
                    fill.style.left = '50%';
                    fill.style.width = (pct - 50) + '%';
                } else {
                    fill.style.left = pct + '%';
                    fill.style.width = (50 - pct) + '%';
                }
                
                // Update display values
                valEl.textContent = bandData.gain.toFixed(1) + 'dB';
                if (freqEl) freqEl.textContent = bandData.freq >= 1000 ? 
                    (bandData.freq / 1000) + 'kHz' : bandData.freq + 'Hz';
                if (qEl) qEl.textContent = bandData.Q.toFixed(1);
            });
        }
        
        function adjustEQBand(dir) {
            const profile = eqProfiles[state.currentCustomEQ];
            if (!profile || !profile.bands || !profile.bands[state.eqEditIdx]) return;
            
            const band = profile.bands[state.eqEditIdx];
            const newVal = Math.max(-12, Math.min(12, band.gain + dir));
            band.gain = newVal;
            
            // Applica in tempo reale
            if (eqFilters[state.eqEditIdx]) {
                eqFilters[state.eqEditIdx].gain.value = newVal;
            }
            
            updateEQEditor();
        }
        
        
        
        // ==================== NOW PLAYING SCRUB (CLICKWHEEL) ====================
        // Center (Now Playing):
        // - Single press: toggle scrub mode (use clickwheel to seek)
        // - Double press (quick, without wheel movement): open Lyrics
        let npSelectTimer = null;
        let npLastSelectTs = 0;

        function npSetProgressUI(t, dur) {
            if (!dur || isNaN(dur) || dur <= 0) return;
            const pct = (t / dur) * 100;
            el.progressFill.style.width = pct + '%';
            el.currentTime.textContent = fmt(t);
            el.remainingTime.textContent = '-' + fmt(Math.max(0, dur - t));
        }

        function npOpenLyrics() {
            if (state.currentSong >= 0) {
                pushHistory('lyrics');
                // Preserve the original loading UI
                el.lyricsContent.innerHTML = `
                        <div class="lyrics-loading">
                            <div class="lyrics-spinner"></div>
                            <div class="lyrics-progress-bar">
                                <div class="lyrics-progress-fill"></div>
                            </div>
                            <div>Searching lyrics...</div>
                            <div class="lyrics-status">Connecting to services...</div>
                        </div>
                    `;
                showView('lyrics', 'forward');
                // Carica i lyrics dopo che la vista è visibile
                setTimeout(() => loadLyrics(), 100);
            }
        }

        function npEnterScrub() {
            if (state.currentSong < 0) return;
            if (crossfadeActive) return; // keep audio state consistent during crossfade

            state.npScrubActive = true;
            try { el.progressBar.classList.add('scrub-active'); } catch (e) {}
            state.npScrubWasPlaying = !!state.playing;
            state.npScrubTarget = (activeAudio && isFinite(activeAudio.currentTime)) ? activeAudio.currentTime : 0;
            state.npScrubLastMoveTs = 0;
            state.npScrubMoved = false;
            state.npScrubEnterTs = performance.now();

            // UI indicator for Now Playing scrubbing
            if (el.nowPlayingView) el.nowPlayingView.classList.add('scrub-active');

            el.progressScrubber.classList.add('dragging');

            if (activeAudio && activeAudio.duration) {
                npSetProgressUI(state.npScrubTarget, activeAudio.duration);
            }
        }

        function npExitScrubUI() {
            state.npScrubActive = false;
            try { el.progressBar.classList.remove('scrub-active'); } catch (e) {}
            if (el.nowPlayingView) el.nowPlayingView.classList.remove('scrub-active');
            el.progressScrubber.classList.remove('dragging');
            state.npScrubWasPlaying = false;
            state.npScrubMoved = false;
        }

        function npConfirmScrub() {
            if (!state.npScrubActive) return;

            // Ensure final position is applied
            if (activeAudio && activeAudio.duration && isFinite(state.npScrubTarget)) {
                try { activeAudio.currentTime = Math.max(0, Math.min(activeAudio.duration, state.npScrubTarget)); } catch (e) {}
            }

            npExitScrubUI();
        }

        function npAdjustScrub(dir) {
            if (!state.npScrubActive) return;
            if (!activeAudio || !activeAudio.duration || !isFinite(activeAudio.duration) || activeAudio.duration <= 0) return;

            const now = performance.now();
            const dt = state.npScrubLastMoveTs ? (now - state.npScrubLastMoveTs) : 999;
            state.npScrubLastMoveTs = now;

            // Slow turns = fine control, fast turns = coarse jumps
            const base = 2; // seconds per notch
            const mult = (dt < 120) ? 6 : (dt < 180) ? 4 : (dt < 260) ? 3 : (dt < 380) ? 2 : 1;
            const step = base * mult;

            state.npScrubMoved = true;
            state.npScrubTarget = Math.max(0, Math.min(activeAudio.duration, state.npScrubTarget + (dir * step)));

            // Apply seek live for responsive control (iPod-like)
            try { activeAudio.currentTime = state.npScrubTarget; } catch (e) {}

            npSetProgressUI(state.npScrubTarget, activeAudio.duration);
        }

function handleSelect() {
            if (state.view === 'menu') {
                const items = el.menuList.querySelectorAll('.menu-item');
                state.menuIdx = clampIndex(state.menuIdx, items.length);
                const action = items[state.menuIdx].dataset.action;
                
                switch (action) {
                    case 'music':
                        pushHistory('musicMenu');
updateMusicMenu();
                        showView('musicMenu', 'forward');
                        break;
                    case 'coverflow':
                        if (state.songs.length > 0) {
                            pushHistory('coverflow');
                            state.cfIdx = ((crossfadeActive && crossfadeState && typeof crossfadeState.nextIdx === 'number') ? crossfadeState.nextIdx : (state.currentSong >= 0 ? state.currentSong : 0));
                            state.cfTargetIdx = state.cfIdx;
                            updateCoverFlow();
                            showView('coverflow', 'forward');
                        }
                        break;
                    case 'nowplaying':
                        if (state.currentSong >= 0) {
                            navigateTo('nowplaying');
                        }
                        break;
                    case 'shuffle':
                        shufflePlay();
                        break;
                    case 'load':
                        el.fileInput.click();
                        break;
                    case 'loadFolder':
                        el.folderInput.click();
                        break;
                    case 'settings':
                        pushHistory('settings');
updateSettings();
                        showView('settings', 'forward');
                        break;
                }
            } else if (state.view === 'musicMenu') {
                const items = el.musicMenuList.querySelectorAll('.menu-item');
                state.musicMenuIdx = clampIndex(state.musicMenuIdx, items.length);
                const action = items[state.musicMenuIdx].dataset.action;
                
                switch (action) {
                    case 'playlists':
                        pushHistory('playlists');
updatePlaylistsList();
                        showView('playlists', 'forward');
                        break;
                    case 'artists':
                        pushHistory('artists');
updateArtistsList();
                        showView('artists', 'forward');
                        break;
                    case 'albums':
                        pushHistory('albums');
state.currentArtist = null; // No artist filter
                        updateAlbumsList();
                        showView('albums', 'forward');
                        break;
                    case 'allsongs':
                        pushHistory('songs');
state.filterType = null;
                        state.filteredSongs = [];
                        updateSongsList();
                        showView('songs', 'forward');
                        break;
                    case 'queue':
                        pushHistory('queue');
updateQueueList();
                        showView('queue', 'forward');
                        break;
                }
            } else if (state.view === 'playlists') {
                const items = el.playlistsList.querySelectorAll('.menu-item');
                state.playlistsIdx = clampIndex(state.playlistsIdx, items.length);
                if (items.length > 0) {
                    const action = items[state.playlistsIdx].dataset.action;
                    if (action === 'new') {
                        createNewPlaylist();
                    } else {
                        const playlistIdx = parseInt(items[state.playlistsIdx].dataset.playlist);
                        if (!isNaN(playlistIdx)) {
                            state.currentPlaylist = playlistIdx;
pushHistory('playlist');
                            updatePlaylistSongs();
                            showView('playlist', 'forward');
                        }
                    }
                }
            } else if (state.view === 'playlist') {
                const items = el.playlistSongsList.querySelectorAll('.menu-item');
                state.playlistIdx = clampIndex(state.playlistIdx, items.length);
                if (items.length > 0) {
                    const action = items[state.playlistIdx].dataset.action;
                    if (action === 'add') {
                        // Add song to playlist
pushHistory('addToPlaylist');
                        updateAddToPlaylistList();
                        showView('addToPlaylist', 'forward');
                    } else if (action === 'rename') {
                        renamePlaylist();
                    } else if (action === 'delete') {
                        deletePlaylist();
                    } else {
                        const playlist = state.playlists[state.currentPlaylist];
                        if (playlist && playlist.songs.length > 0) {
                            // Position in playlist (subtract 3 for action items)
                            const playlistPos = state.playlistIdx - 3;
                            if (playlistPos >= 0 && playlistPos < playlist.songs.length) {
                                // Start playback with playlist context
                                startPlayback(playlist.songs.slice(), playlistPos, 'playlist');
                                navigateTo('nowplaying');
                            }
                        }
                    }
                }
            } else if (state.view === 'addToPlaylist') {
                const items = el.addToPlaylistList.querySelectorAll('.menu-item');
                state.addToPlaylistIdx = clampIndex(state.addToPlaylistIdx, items.length);
                if (items.length > 0) {
                    const songIdx = parseInt(items[state.addToPlaylistIdx].dataset.song);
                    if (!isNaN(songIdx)) {
                        addSongToPlaylist(songIdx);
                    }
                }
            } else if (state.view === 'queue') {
                const items = el.queueList.querySelectorAll('.menu-item');
                state.queueIdx = clampIndex(state.queueIdx, items.length);
                if (items.length > 0 && state.queue.length > 0) {
                    const action = items[state.queueIdx].dataset.action;
                    if (action === 'clearQueue') {
                        clearQueue();
                    } else {
                        const songIdx = parseInt(items[state.queueIdx].dataset.song);
                        if (!isNaN(songIdx)) {
                            const pos = parseInt(items[state.queueIdx].dataset.pos);
                            // Start playback with queue context
                            startPlayback(state.queue.slice(), pos, 'queue');
                            // Remove played song from actual queue
                            state.queue.splice(pos, 1);
                            updateQueueList();
                            navigateTo('nowplaying');
                        }
                    }
                }
            } else if (state.view === 'artists') {
                const items = el.artistsList.querySelectorAll('.menu-item');
                state.artistIdx = clampIndex(state.artistIdx, items.length);
                if (items.length > 0 && items[state.artistIdx].dataset.artist) {
                    const artist = items[state.artistIdx].dataset.artist;
                    state.currentArtist = artist;
                    pushHistory('artistAlbums');
updateArtistAlbumsList(artist);
                    showView('artistAlbums', 'forward');
                }
            } else if (state.view === 'artistAlbums') {
                const items = el.artistAlbumsList.querySelectorAll('.menu-item');
                state.artistAlbumsIdx = clampIndex(state.artistAlbumsIdx, items.length);
                if (items.length > 0 && items[state.artistAlbumsIdx].dataset.album) {
                    const album = items[state.artistAlbumsIdx].dataset.album;
                    state.currentAlbum = album;
                    pushHistory('albumSongs');
updateAlbumSongsList(state.currentArtist, album);
                    showView('albumSongs', 'forward');
                }
            } else if (state.view === 'albums') {
                const items = el.albumsList.querySelectorAll('.menu-item');
                state.albumIdx = clampIndex(state.albumIdx, items.length);
                if (items.length > 0 && items[state.albumIdx].dataset.album) {
                    const album = items[state.albumIdx].dataset.album;
                    const artist = items[state.albumIdx].dataset.artist || null;
                    state.currentAlbum = album;
                    state.currentArtist = artist; // Use artist from data attribute
                    pushHistory('albumSongs');
updateAlbumSongsList(artist, album);
                    showView('albumSongs', 'forward');
                }
            } else if (state.view === 'albumSongs') {
                const items = el.albumSongsList.querySelectorAll('.menu-item');
                state.albumSongsIdx = clampIndex(state.albumSongsIdx, items.length);
                if (items.length > 0) {
                    // Get song indices for this album (optionally filtered by artist)
                    const albumSongs = getAlbumSongs(state.currentArtist, state.currentAlbum);
                    if (albumSongs.length > 0) {
                        const songIndices = albumSongs.map(song => state.songs.indexOf(song));
                        startPlayback(songIndices, state.albumSongsIdx, 'album');
                        navigateTo('nowplaying');
                    }
                }
            } else if (state.view === 'songs') {
                const songsToUse = state.filteredSongs.length > 0 ? state.filteredSongs : state.songs;
                if (songsToUse.length > 0) {
                    // Build list of song indices for playback context
                    const songIndices = songsToUse.map(song => state.songs.indexOf(song));
                    startPlayback(songIndices, state.songIdx, 'all');
                    navigateTo('nowplaying');
                }
            } else if (state.view === 'settings') {
                const items = el.settingsList.querySelectorAll('.menu-item');
                state.settingsIdx = clampIndex(state.settingsIdx, items.length);
                const action = items[state.settingsIdx].dataset.action;
                handleSetting(action);
            } else if (state.view === 'eq') {
                // Simple click selects/applies the preset
                const items = el.eqList.querySelectorAll('.menu-item');
                state.eqIdx = clampIndex(state.eqIdx, items.length);
                const key = items[state.eqIdx].dataset.profile;
                
                state.eqProfile = key;
                applyEQProfile(key);
                saveState();
                updateEQList();
                updateSettings();
                showToast(`EQ: ${eqProfiles[key].name} ✓`);
            } else if (state.view === 'eqEdit') {
                if (state.eqEditMode) {
                    // Confirm the band value and exit edit mode
                    state.eqEditMode = false;
                    saveCustomEQ();
                    updateEQEditor();
                    showToast('Value saved');
                } else {
                    // Enter edit mode for the selected band
                    state.eqEditMode = true;
                    updateEQEditor();
                }
            } else if (state.view === 'nowplaying') {
                // Center button behavior (Now Playing):
                // - Double press (quick): enable clickwheel scrubbing (seek)
                // - Single press (after delay): Lyrics
                const now = performance.now();

                // If already scrubbing: single press confirms/exits scrub mode.
                if (state.npScrubActive) {
                    npLastSelectTs = 0;
                    if (npSelectTimer) { clearTimeout(npSelectTimer); npSelectTimer = null; }
                    npConfirmScrub();
                    return;
                }

                // 4. Finestra doppio click più ampia (450ms invece di 320ms)
                const isDouble = (npLastSelectTs && (now - npLastSelectTs) < 450);
                if (isDouble) {
                    npLastSelectTs = 0;
                    if (npSelectTimer) { clearTimeout(npSelectTimer); npSelectTimer = null; }
                    npEnterScrub();
                    return;
                }

                // Arm a short window to detect a double-tap. If it doesn't happen, open Lyrics.
                npLastSelectTs = now;
                if (npSelectTimer) { clearTimeout(npSelectTimer); npSelectTimer = null; }
                // 4. Aumenta il delay prima di aprire lyrics (400ms invece di 260ms)
                npSelectTimer = setTimeout(() => {
                    npSelectTimer = null;
                    npLastSelectTs = 0;
                    if (state.view === 'nowplaying' && !state.npScrubActive) {
                        npOpenLyrics();
                    }
                }, 400);

                return;
} else if (state.view === 'coverflow') {
                if (state.albumsCF.length > 0) {
                    const albumData = state.albumsCF[state.cfIdx];
                    if (albumData) {
                        state.currentArtist = albumData.artist;
                        state.currentAlbum = albumData.album;
                        pushHistory('albumSongs');
                        state.albumSongsIdx = 0;
                        updateAlbumSongsList(albumData.artist, albumData.album);
                        showView('albumSongs', 'forward');
                    }
                }
            } else if (state.view === 'keyboard') {
                handleKeyboardInput();
            } else if (state.view === 'lyrics') {
                goBack();
            }
        }
        
        function goBack() {
            // Debug
            console.log('goBack - current view:', state.view, 'history:', [...state.history]);
            
            // Limit history size to prevent memory issues
            if (state.history.length > 50) {
                state.history = state.history.slice(-25);
            }
            
            // Cleanup: rimuovi duplicati consecutivi dalla history
            while (state.history.length > 1 && 
                   state.history[state.history.length - 1] === state.history[state.history.length - 2]) {
                state.history.pop();
            }
            
            // Assicurati che la vista corrente sia nella history
            if (state.history[state.history.length - 1] !== state.view) {
                // La history non è sincronizzata, aggiusta
                console.log('History desync detected, fixing...');
                state.history.push(state.view);
            }
            
            // Se stiamo uscendo da EQ senza selezionare, ripristina il profilo originale
            if (state.view === 'eq') {
                applyEQProfile(state.eqProfile);
            }
            
            // Stop karaoke and clear synced data if leaving lyrics
            if (state.view === 'lyrics') {
                stopKaraoke();
                syncedLyricsData = null; // Clear to prevent restarting on play/pause
            }
            
            // Cancel keyboard input
            if (state.view === 'keyboard') {
                state.keyboardCallback = null;
            }
            
            if (state.history.length > 1) {
                state.history.pop();
                const prev = state.history[state.history.length - 1];
                console.log('Going back to:', prev);
                showView(prev, 'back');
            }
        }
        
        // Helper per evitare duplicati nella history
        function pushHistory(viewName) {
            if (state.history[state.history.length - 1] !== viewName) {
                state.history.push(viewName);
            }
        }
        
        // Naviga a una nuova view
        function navigateTo(viewName) {
            pushHistory(viewName);
            showView(viewName, 'forward');
        }
        
        // ==================== TOAST & CONFIRM ====================
        let toastTimeout = null;
        function showToast(message, duration = 2000) {
            el.toast.textContent = message;
            el.toast.classList.add('active');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                el.toast.classList.remove('active');
            }, duration);
        }
        
        let confirmCallback = null;
        function showConfirm(title, message, onConfirm) {
            el.confirmTitle.textContent = title;
            el.confirmMessage.textContent = message;
            confirmCallback = onConfirm;
            el.confirmModal.classList.add('active');
        }
        
        function hideConfirm() {
            el.confirmModal.classList.remove('active');
            confirmCallback = null;
        }
        
        // Confirm modal event listeners
        el.confirmCancel.addEventListener('click', () => {
            selectSound();
            hideConfirm();
        });
        
        el.confirmOk.addEventListener('click', () => {
            selectSound();
            if (confirmCallback) confirmCallback();
            hideConfirm();
        });

        // ==================== SETTINGS ====================
        function handleSetting(action) {
            switch (action) {
                case 'repeat':
                    state.repeat = state.repeat === 'off' ? 'all' : state.repeat === 'all' ? 'one' : 'off';
                    updateNowPlaying(); // Update status icons
                    break;
                case 'shuffleToggle':
                    state.shuffle = !state.shuffle;
                    if (state.shuffle) genShuffleQueue();
                    updateNowPlaying(); // Update status icons
                    break;
                case 'eq':
                    initAudio();
                    if (!webAudioReady) setupAudioAnalyser();
                    eqPreviewWarningShown = false;
                    pushHistory('eq');
                    const eqKeys = Object.keys(eqProfiles);
                    state.eqIdx = Math.max(0, eqKeys.indexOf(state.eqProfile));
                    updateEQList();
                    showView('eq', 'forward');
                    return;
                case 'crossfade':
                    // Cycle: Off -> 2s -> 4s -> 6s -> 8s -> 10s -> Off
                    const crossfadeValues = [0, 2, 4, 6, 8, 10];
                    const cfIdx = crossfadeValues.indexOf(state.crossfade);
                    state.crossfade = crossfadeValues[(cfIdx + 1) % crossfadeValues.length];
                    showToast(`Crossfade: ${state.crossfade === 0 ? 'Off' : state.crossfade + 's'}`);
                    break;
                case 'gapless':
                    state.gapless = !state.gapless;
                    showToast(`Gapless: ${state.gapless ? 'On' : 'Off'}`);
                    break;
                case 'replayGain':
                    state.replayGain = !state.replayGain;
                    applyReplayGain();
                    showToast(`Replay Gain: ${state.replayGain ? 'On' : 'Off'}`);
                    break;
                case 'clickSound':
                    state.clickSound = !state.clickSound;
                    showToast(`Click Sound: ${state.clickSound ? 'On' : 'Off'}`);
                    break;
                case 'hapticFeedback':
                    state.hapticFeedback = !state.hapticFeedback;
                    showToast(`Haptic Feedback: ${state.hapticFeedback ? 'On' : 'Off'}`);
                    if (state.hapticFeedback) {
                        const ok = safeVibrate(28, 0);
                        if (!ok) showToast('Vibration not available (use HTTPS/localhost + enable system vibration).');
                    }
                    break;
                case 'theme':
                    state.theme = state.theme === 'white' ? 'black' : 'white';
                    applyTheme();
                    break;
                case 'clearQueue':
                    if (state.queue.length === 0) {
                        showToast('Queue is empty');
                        return;
                    }
                    clearQueue();
                    return;
                case 'clearAll':
                    if (state.songs.length === 0) {
                        showToast('No songs to clear');
                        return;
                    }
                    showConfirm(
                        'Clear All Songs',
                        `Delete all ${state.songs.length} songs from your library?`,
                        () => {
                            // Cancel any active crossfade
                            cancelCrossfade();
                            // Revoke blob URLs to free memory
                            state.songs.forEach(song => {
                                if (song.url && song.url.startsWith('blob:')) {
                                    URL.revokeObjectURL(song.url);
                                }
                                // Also revoke artwork blob URLs
                                if (song.artwork && song.artwork.startsWith('blob:')) {
                                    URL.revokeObjectURL(song.artwork);
                                }
                            });
                            state.songs = [];
                            state.playbackList = [];
                            state.currentSong = -1;
                            state.queue = [];
                            // Reset both audio elements
                            try { activeAudio.pause(); } catch (e) {}
                            activeAudio.src = '';
                            try { inactiveAudio.pause(); } catch (e) {}
                            inactiveAudio.src = '';
                            // Reset pointers
                            activeAudio = audio;
                            inactiveAudio = audio2;
                            updateSongsList();
                            updateNowPlaying();
                            showToast('All songs cleared ✓');
                        }
                    );
                    return;
            }
            updateSettings();
            saveState();
        }
        
        // Apply replay gain normalization
        function applyReplayGain() {
            if (state.replayGain) {
                // Normalize volume to ~89dB (typical replay gain target)
                // This is a simplified implementation - real replay gain needs metadata
                activeAudio.volume = Math.min(state.volume * 0.8, 1.0);
            } else {
                activeAudio.volume = state.volume;
            }
        }
        
        function updateSettings() {
            const labels = { off: 'Off', all: 'All', one: 'One' };
            el.repeatValue.textContent = labels[state.repeat];
            el.shuffleValue.textContent = state.shuffle ? 'On' : 'Off';
            el.themeValue.textContent = state.theme === 'white' ? 'White' : 'Black';
            if (el.eqValue) {
                el.eqValue.textContent = eqProfiles[state.eqProfile]?.name || 'Flat';
            }
            if (el.crossfadeValue) {
                el.crossfadeValue.textContent = state.crossfade === 0 ? 'Off' : state.crossfade + 's';
            }
            if (el.gaplessValue) {
                el.gaplessValue.textContent = state.gapless ? 'On' : 'Off';
            }
            if (el.replayGainValue) {
                el.replayGainValue.textContent = state.replayGain ? 'On' : 'Off';
            }
            if (el.clickSoundValue) {
                el.clickSoundValue.textContent = state.clickSound ? 'On' : 'Off';
            }
            if (el.hapticValue) {
                el.hapticValue.textContent = state.hapticFeedback ? 'On' : 'Off';
            }
            
            const items = el.settingsList.querySelectorAll('.menu-item');
            state.settingsIdx = clampIndex(state.settingsIdx, items.length);
            items.forEach((item, i) => item.classList.toggle('selected', i === state.settingsIdx));
        }

        // ==================== THEME ====================
        function applyTheme() {
            el.ipod.classList.toggle('black-theme', state.theme === 'black');
            document.body.classList.toggle('light-bg', state.theme === 'black');
        }

        // ==================== SONGS LIST ====================
        function updateMusicMenu() {
            const items = el.musicMenuList.querySelectorAll('.menu-item');
            state.musicMenuIdx = clampIndex(state.musicMenuIdx, items.length);
            items.forEach((item, i) => {
                item.classList.toggle('selected', i === state.musicMenuIdx);
            });
        }
        
        function updateSongsList(filterAlbum = null) {
            let songsToShow = state.songs;
            
            // Filtra per album se specificato
            if (filterAlbum) {
                songsToShow = state.songs.filter(s => s.album === filterAlbum);
                state.filteredSongs = songsToShow;
            } else if (state.filterType === 'artist' && state.filterValue) {
                songsToShow = state.songs.filter(s => s.artist === state.filterValue);
                state.filteredSongs = songsToShow;
            } else {
                state.filteredSongs = [];
            }
            
            if (songsToShow.length === 0) {
                el.songsList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No songs</span></div>';
                return;
            }
            
            // 5. Ordina alfabeticamente per titolo
            songsToShow = [...songsToShow].sort((a, b) => {
                const titleA = (a.title || '').toLowerCase();
                const titleB = (b.title || '').toLowerCase();
                return titleA.localeCompare(titleB);
            });
            
            // Se non è filtrato, aggiorna anche l'array di riferimento
            if (!filterAlbum && !state.filterType) {
                state.filteredSongs = songsToShow;
            }
            
            state.songIdx = clampIndex(state.songIdx, songsToShow.length);
            
            el.songsList.innerHTML = songsToShow.map((s, i) => `
                <div class="menu-item ${i === state.songIdx ? 'selected' : ''}" data-index="${i}">
                    <div class="song-item-content">
                        <div class="song-item-title">${esc(s.title)}</div>
                        <div class="song-item-artist">${esc(s.artist)}</div>
                    </div>
                    <span class="arrow">›</span>
                </div>
            `).join('');
        }
        
        function updateArtistsList() {
            // Estrai artisti unici
            const artists = [...new Set(state.songs.map(s => s.artist || 'Unknown Artist'))].sort();
            
            if (artists.length === 0) {
                el.artistsList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No artists</span></div>';
                return;
            }
            state.artistIdx = clampIndex(state.artistIdx, artists.length);
            
            el.artistsList.innerHTML = artists.map((artist, i) => {
                const count = state.songs.filter(s => (s.artist || 'Unknown Artist') === artist).length;
                return `
                    <div class="menu-item ${i === state.artistIdx ? 'selected' : ''}" data-artist="${esc(artist)}">
                        <div class="song-item-content">
                            <div class="song-item-title">${esc(artist)}</div>
                            <div class="song-item-artist">${count} song${count !== 1 ? 's' : ''}</div>
                        </div>
                        <span class="arrow">›</span>
                    </div>
                `;
            }).join('');
        }
        
        function updateAlbumsList(filterArtist = null) {
            let songs = state.songs;
            
            // Filtra per artista se specificato
            if (filterArtist) {
                songs = state.songs.filter(s => s.artist === filterArtist);
            }
            
            // Estrai album unici usando chiave combinata artista+album per evitare collisioni
            const albumMap = new Map();
            songs.forEach(s => {
                const album = s.album || 'Unknown Album';
                const artist = s.artist || 'Unknown Artist';
                const key = `${artist}|||${album}`; // Unique key
                if (!albumMap.has(key)) {
                    albumMap.set(key, { album, artist, songs: [] });
                }
                albumMap.get(key).songs.push(s);
            });
            
            // Convert to array and sort by album name
            const albums = Array.from(albumMap.values()).sort((a, b) => a.album.localeCompare(b.album));
            
            if (albums.length === 0) {
                el.albumsList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No albums</span></div>';
                return;
            }
            state.albumIdx = clampIndex(state.albumIdx, albums.length);
            
            el.albumsList.innerHTML = albums.map((item, i) => {
                const count = item.songs.length;
                return `
                    <div class="menu-item ${i === state.albumIdx ? 'selected' : ''}" data-album="${esc(item.album)}" data-artist="${esc(item.artist)}">
                        <div class="song-item-content">
                            <div class="song-item-title">${esc(item.album)}</div>
                            <div class="song-item-artist">${esc(item.artist)} · ${count} song${count !== 1 ? 's' : ''}</div>
                        </div>
                        <span class="arrow">›</span>
                    </div>
                `;
            }).join('');
        }
        
        // Shows albums for a specific artist
        function updateArtistAlbumsList(artist) {
            const artistSongs = state.songs.filter(s => (s.artist || 'Unknown Artist') === artist);
            const albums = [...new Set(artistSongs.map(s => s.album || 'Unknown Album'))].sort();
            
            if (albums.length === 0) {
                el.artistAlbumsList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No albums</span></div>';
                return;
            }
            state.artistAlbumsIdx = clampIndex(state.artistAlbumsIdx, albums.length);
            
            el.artistAlbumsList.innerHTML = albums.map((album, i) => {
                const albumSongs = artistSongs.filter(s => (s.album || 'Unknown Album') === album);
                const count = albumSongs.length;
                return `
                    <div class="menu-item ${i === state.artistAlbumsIdx ? 'selected' : ''}" data-album="${esc(album)}">
                        <div class="song-item-content">
                            <div class="song-item-title">${esc(album)}</div>
                            <div class="song-item-artist">${count} song${count !== 1 ? 's' : ''}</div>
                        </div>
                        <span class="arrow">›</span>
                    </div>
                `;
            }).join('');
        }
        
        // Shows songs for a specific album (optionally filtered by artist)
        function updateAlbumSongsList(artist, album) {
            const songs = getAlbumSongs(artist, album);
            
            if (songs.length === 0) {
                el.albumSongsList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No songs</span></div>';
                return;
            }
            state.albumSongsIdx = clampIndex(state.albumSongsIdx, songs.length);
            
            el.albumSongsList.innerHTML = songs.map((song, i) => {
                return `
                    <div class="menu-item ${i === state.albumSongsIdx ? 'selected' : ''}" data-song="${state.songs.indexOf(song)}">
                        <div class="song-item-content">
                            <div class="song-item-title">${esc(song.title)}</div>
                            <div class="song-item-artist">${esc(song.artist)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Helper to get songs for an album (optionally filtered by artist)
        function getAlbumSongs(artist, album) {
            return state.songs.filter(s => {
                const matchAlbum = (s.album || 'Unknown Album') === album;
                if (artist) {
                    const matchArtist = (s.artist || 'Unknown Artist') === artist;
                    return matchAlbum && matchArtist;
                }
                return matchAlbum;
            });
        }
        
        function esc(str) {
            const div = document.createElement('div');
            div.textContent = str || '';
            return div.innerHTML;
        }

        function clampIndex(idx, len) {
            if (!Number.isFinite(idx)) idx = 0;
            if (!len || len <= 0) return 0;
            if (idx < 0) return 0;
            if (idx > len - 1) return len - 1;
            return idx;
        }
        
        // ==================== DELETE FUNCTIONS ====================
        // 3. Long press on MENU button for delete
        function handleMenuLongPress() {
            clearHold();
            
            // Only in music-related views
            if (state.view === 'songs') {
                const songsToUse = state.filteredSongs.length > 0 ? state.filteredSongs : state.songs;
                if (songsToUse.length > 0) {
                    const song = songsToUse[state.songIdx];
                    confirmDeleteSong(song);
                }
            } else if (state.view === 'artists') {
                const artists = [...new Set(state.songs.map(s => s.artist || 'Unknown Artist'))].sort();
                if (artists.length > 0 && state.artistIdx < artists.length) {
                    const artist = artists[state.artistIdx];
                    confirmDeleteArtist(artist);
                }
            } else if (state.view === 'albums') {
                const items = el.albumsList.querySelectorAll('.menu-item');
                if (items.length > 0 && state.albumIdx < items.length) {
                    const album = items[state.albumIdx].dataset.album;
                    const artist = items[state.albumIdx].dataset.artist;
                    confirmDeleteAlbum(album, artist);
                }
            } else if (state.view === 'albumSongs') {
                const songs = getAlbumSongs(state.currentArtist, state.currentAlbum);
                if (songs.length > 0 && state.albumSongsIdx < songs.length) {
                    const song = songs[state.albumSongsIdx];
                    confirmDeleteSong(song);
                }
            }
        }
        
        function confirmDeleteSong(song) {
            if (!song) return;
            showConfirm(
                'Delete Song',
                `Delete "${song.title}"?`,
                () => {
                    deleteSong(song);
                }
            );
        }
        
        function confirmDeleteArtist(artist) {
            const count = state.songs.filter(s => (s.artist || 'Unknown Artist') === artist).length;
            showConfirm(
                'Delete Artist',
                `Delete all ${count} song${count !== 1 ? 's' : ''} by "${artist}"?`,
                () => {
                    deleteArtist(artist);
                }
            );
        }
        
        function confirmDeleteAlbum(album, artist) {
            const songs = getAlbumSongs(artist, album);
            showConfirm(
                'Delete Album',
                `Delete "${album}" (${songs.length} song${songs.length !== 1 ? 's' : ''})?`,
                () => {
                    deleteAlbum(album, artist);
                }
            );
        }
        
        function deleteSong(song) {
            const idx = state.songs.indexOf(song);
            if (idx === -1) return;
            
            // Revoke blob URLs to prevent memory leaks
            if (song.url && song.url.startsWith('blob:')) {
                URL.revokeObjectURL(song.url);
            }
            // Also revoke artwork blob URL if present
            if (song.artwork && song.artwork.startsWith('blob:')) {
                URL.revokeObjectURL(song.artwork);
            }
            
            // Remove from songs array
            state.songs.splice(idx, 1);
            
            // Update playlists
            state.playlists.forEach(p => {
                p.songs = p.songs.filter(i => i !== idx).map(i => i > idx ? i - 1 : i);
            });
            
            // Update queue
            state.queue = state.queue.filter(i => i !== idx).map(i => i > idx ? i - 1 : i);
            
            // Update current song index
            if (state.currentSong === idx) {
                state.currentSong = -1;
                activeAudio.pause();
                activeAudio.src = '';
                state.playing = false;
            } else if (state.currentSong > idx) {
                state.currentSong--;
            }
            
            // Update playback list
            state.playbackList = state.playbackList.filter(i => i !== idx).map(i => i > idx ? i - 1 : i);
            
            // Refresh UI
            updateSongsList();
            updateCoverFlow();
            showToast('Song deleted ✓');
        }
        
        function deleteArtist(artist) {
            const songsToDelete = state.songs.filter(s => (s.artist || 'Unknown Artist') === artist);
            songsToDelete.forEach(song => deleteSong(song));
            updateArtistsList();
            showToast(`Artist "${artist}" deleted ✓`);
        }
        
        function deleteAlbum(album, artist) {
            const songsToDelete = getAlbumSongs(artist, album);
            songsToDelete.forEach(song => deleteSong(song));
            updateAlbumsList();
            showToast(`Album "${album}" deleted ✓`);
        }
        
        // ==================== QUEUE ====================
        function updateQueueList() {
            if (state.queue.length === 0) {
                el.queueList.innerHTML = `
                    <div class="menu-item selected" style="opacity:0.5">
                        <span>Queue is empty</span>
                    </div>
                    <div class="menu-item" style="opacity:0.7; font-size: 10px; padding: 8px 12px;">
                        <span>Long-press a song to add to queue</span>
                    </div>
                `;
                return;
            }
            
            state.queueIdx = clampIndex(state.queueIdx, state.queue.length + 1);
            
            let html = `
                <div class="menu-item ${state.queueIdx === 0 ? 'selected' : ''}" data-action="clearQueue">
                    <span style="color:#c00">Clear Queue (${state.queue.length} songs)</span>
                </div>
            `;
            
            state.queue.forEach((songIdx, i) => {
                const song = state.songs[songIdx];
                if (song) {
                    html += `
                        <div class="menu-item ${state.queueIdx === i + 1 ? 'selected' : ''}" data-song="${songIdx}" data-pos="${i}">
                            <div class="song-item-content">
                                <div class="song-item-title">${i + 1}. ${esc(song.title)}</div>
                                <div class="song-item-artist">${esc(song.artist)}</div>
                            </div>
                        </div>
                    `;
                }
            });
            
            el.queueList.innerHTML = html;
        }
        
        function addToQueue(songIdx) {
            if (songIdx < 0 || songIdx >= state.songs.length) return;
            state.queue.push(songIdx);
            const song = state.songs[songIdx];
            showToast(`Added to queue: ${song.title}`);
        }
        
        function removeFromQueue(position) {
            if (position < 0 || position >= state.queue.length) return;
            state.queue.splice(position, 1);
            state.queueIdx = Math.min(state.queueIdx, state.queue.length);
            updateQueueList();
            showToast('Removed from queue');
        }
        
        function clearQueue() {
            state.queue = [];
updateQueueList();
            showToast('Queue cleared');
        }
        
        // ==================== PLAYLISTS ====================
        function updatePlaylistsList() {
            state.playlistsIdx = clampIndex(state.playlistsIdx, (state.playlists?.length || 0) + 1);
            let html = `
                <div class="menu-item ${state.playlistsIdx === 0 ? 'selected' : ''}" data-action="new">
                    <span>+ New Playlist...</span>
                </div>
            `;
            
            state.playlists.forEach((playlist, i) => {
                html += `
                    <div class="menu-item ${state.playlistsIdx === i + 1 ? 'selected' : ''}" data-playlist="${i}">
                        <span>${esc(playlist.name)}</span>
                        <span class="arrow">›</span>
                    </div>
                `;
            });
            
            el.playlistsList.innerHTML = html;
        }
        
        function updatePlaylistSongs() {
            const playlist = state.playlists[state.currentPlaylist];
            if (!playlist) return;
            state.playlistIdx = clampIndex(state.playlistIdx, (playlist.songs?.length || 0) + 3);
            
            let html = `
                <div class="menu-item ${state.playlistIdx === 0 ? 'selected' : ''}" data-action="add">
                    <span>+ Add Songs...</span>
                </div>
                <div class="menu-item ${state.playlistIdx === 1 ? 'selected' : ''}" data-action="rename">
                    <span>Rename Playlist</span>
                </div>
                <div class="menu-item ${state.playlistIdx === 2 ? 'selected' : ''}" data-action="delete">
                    <span style="color:#c00">Delete Playlist</span>
                </div>
            `;
            
            playlist.songs.forEach((songIdx, i) => {
                const song = state.songs[songIdx];
                if (song) {
                    html += `
                        <div class="menu-item ${state.playlistIdx === i + 3 ? 'selected' : ''}" data-song="${songIdx}" data-pos="${i}">
                            <div class="song-item-content">
                                <div class="song-item-title">${esc(song.title)}</div>
                                <div class="song-item-artist">${esc(song.artist)}</div>
                            </div>
                        </div>
                    `;
                }
            });
            
            if (playlist.songs.length === 0) {
                html += `<div class="menu-item" style="opacity:0.5"><span>No songs in playlist</span></div>`;
            }
            
            el.playlistSongsList.innerHTML = html;
        }
        
        function updateAddToPlaylistList() {
            if (state.songs.length === 0) {
                el.addToPlaylistList.innerHTML = '<div class="menu-item selected" style="opacity:0.5"><span>No songs available</span></div>';
                return;
            }
            
            el.addToPlaylistList.innerHTML = state.songs.map((song, i) => `
                <div class="menu-item ${i === state.addToPlaylistIdx ? 'selected' : ''}" data-song="${i}">
                    <div class="song-item-content">
                        <div class="song-item-title">${esc(song.title)}</div>
                        <div class="song-item-artist">${esc(song.artist)}</div>
                    </div>
                </div>
            `).join('');
        }
        
        function createNewPlaylist() {
            openKeyboard('New Playlist', `Playlist ${state.playlists.length + 1}`, (name) => {
                state.playlists.push({ name: name, songs: [] });
                saveState();
                updatePlaylistsList();
                showToast(`Created "${name}"`);
            });
        }
        
        function renamePlaylist() {
            const playlist = state.playlists[state.currentPlaylist];
            if (!playlist) return;
            
            openKeyboard('Rename Playlist', playlist.name, (name) => {
                playlist.name = name;
                saveState();
                updatePlaylistSongs();
                showView('playlist', 'forward'); // Refresh title
                showToast(`Renamed to "${name}"`);
            });
        }
        
        function deletePlaylist() {
            const playlist = state.playlists[state.currentPlaylist];
            if (!playlist) return;
            
            showConfirm('Delete Playlist', `Delete "${playlist.name}"?`, () => {
                state.playlists.splice(state.currentPlaylist, 1);
                state.currentPlaylist = null;
                saveState();
                goBack();
                showToast('Playlist deleted');
            });
        }
        
        function addSongToPlaylist(songIdx) {
            const playlist = state.playlists[state.currentPlaylist];
            if (!playlist) return;
            
            // Check if already in playlist
            if (playlist.songs.includes(songIdx)) {
                showToast('Song already in playlist');
                return;
            }
            
            playlist.songs.push(songIdx);
            saveState();
            showToast(`Added to "${playlist.name}"`);
        }
        
        function removeSongFromPlaylist(position) {
            const playlist = state.playlists[state.currentPlaylist];
            if (!playlist) return;
            
            const song = state.songs[playlist.songs[position]];
            showConfirm('Remove Song', `Remove "${song?.title}" from playlist?`, () => {
                playlist.songs.splice(position, 1);
                saveState();
                state.playlistIdx = Math.min(state.playlistIdx, playlist.songs.length + 2);
                updatePlaylistSongs();
                showToast('Song removed');
            });
        }

        // ==================== VIRTUAL KEYBOARD ====================
        const KEYBOARD_CHARS = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G',
            'H', 'I', 'J', 'K', 'L', 'M', 'N',
            'O', 'P', 'Q', 'R', 'S', 'T', 'U',
            'V', 'W', 'X', 'Y', 'Z', '0', '1',
            '2', '3', '4', '5', '6', '7', '8',
            '9', ' ', '⌫', 'OK'
        ];
        
        function initKeyboard() {
            el.keyboardGrid.innerHTML = KEYBOARD_CHARS.map((char, i) => {
                let cls = 'keyboard-key';
                if (char === ' ') cls += ' wide';
                if (char === '⌫' || char === 'OK') cls += ' action';
                if (i === state.keyboardIdx) cls += ' selected';
                
                const display = char === ' ' ? 'SPACE' : char;
                return `<div class="${cls}" data-char="${char}" data-idx="${i}">${display}</div>`;
            }).join('');
        }
        
        function updateKeyboardDisplay() {
            // Update selected key
            const keys = el.keyboardGrid.querySelectorAll('.keyboard-key');
            keys.forEach((key, i) => {
                key.classList.toggle('selected', i === state.keyboardIdx);
            });
            
            // Scroll selected key into view
            if (keys[state.keyboardIdx]) {
                keys[state.keyboardIdx].scrollIntoView({ block: 'nearest' });
            }
            
            // Update text display
            el.keyboardText.innerHTML = state.keyboardText + '<span class="keyboard-input-cursor"></span>';
        }
        
        function openKeyboard(title, initialText, callback) {
            state.keyboardTitle = title;
            state.keyboardText = initialText || '';
            state.keyboardIdx = 0;
            state.keyboardCallback = callback;
            
            initKeyboard();
            updateKeyboardDisplay();
            
            pushHistory('keyboard');
            showView('keyboard', 'forward');
        }
        
        function handleKeyboardInput() {
            const char = KEYBOARD_CHARS[state.keyboardIdx];
            
            if (char === 'OK') {
                // Confirm input
                const text = state.keyboardText.trim();
                const callback = state.keyboardCallback;
                state.keyboardCallback = null;
                goBack();
                if (callback && text) {
                    callback(text);
                }
            } else if (char === '⌫') {
                // Backspace
                state.keyboardText = state.keyboardText.slice(0, -1);
                updateKeyboardDisplay();
            } else {
                // Add character
                if (state.keyboardText.length < 30) {
                    state.keyboardText += char;
                    updateKeyboardDisplay();
                }
            }
        }
        
        function scrollKeyboard(dir) {
            const total = KEYBOARD_CHARS.length;
            state.keyboardIdx = Math.max(0, Math.min(total - 1, state.keyboardIdx + dir));
            updateKeyboardDisplay();
        }

        // ==================== COVER FLOW ====================
        let cfDrag = { active: false, startX: 0, startIdx: 0, moved: false };
        let cfItems = []; // Riferimenti agli elementi DOM
        
        // Build album index for CoverFlow (sorted by artist then album)
        function buildAlbumsCF() {
            const albumMap = new Map();
            
            state.songs.forEach((song, songIdx) => {
                const artist = song.artist || 'Unknown Artist';
                const album = song.album || 'Unknown Album';
                const key = `${artist}\0${album}`;
                
                if (!albumMap.has(key)) {
                    albumMap.set(key, {
                        artist,
                        album,
                        artwork: song.artwork || null,
                        songIndices: []
                    });
                }
                
                const entry = albumMap.get(key);
                entry.songIndices.push(songIdx);
                // Use first available artwork
                if (!entry.artwork && song.artwork) {
                    entry.artwork = song.artwork;
                }
            });
            
            // Convert to array and sort by artist then album
            state.albumsCF = Array.from(albumMap.values()).sort((a, b) => {
                const artistCmp = a.artist.localeCompare(b.artist, undefined, { sensitivity: 'base' });
                if (artistCmp !== 0) return artistCmp;
                return a.album.localeCompare(b.album, undefined, { sensitivity: 'base' });
            });
        }
        
        function initCoverFlow() {
            // Build album index
            buildAlbumsCF();
            
            // Crea tutti gli elementi DOM per le copertine degli album
            el.coverflowTrack.innerHTML = '';
            cfItems = [];
            
            // Reset index if out of bounds
            if (state.cfIdx >= state.albumsCF.length) {
                state.cfIdx = 0;
                state.cfTargetIdx = 0;
            }
            
            state.albumsCF.forEach((albumData, i) => {
                const item = document.createElement('div');
                item.className = 'coverflow-item';
                item.dataset.index = i;
                
                if (albumData.artwork) {
                    item.innerHTML = `<img src="${albumData.artwork}" alt="">`;
                } else {
                    item.innerHTML = `<div class="no-art-cf">♫</div>`;
                }
                
                item.addEventListener('click', () => {
                    if (!cfDrag.moved) {
                        if (i === state.cfIdx) {
                            // Click sulla cover centrale = apri lista brani dell'album
                            state.currentArtist = albumData.artist;
                            state.currentAlbum = albumData.album;
                            pushHistory('albumSongs');
                            state.albumSongsIdx = 0;
                            updateAlbumSongsList(albumData.artist, albumData.album);
                            showView('albumSongs', 'forward');
                        } else {
                            // Click su altra cover = vai a quella cover
                            smoothScrollCF(i);
                        }
                    }
                });
                
                el.coverflowTrack.appendChild(item);
                cfItems.push(item);
            });
            
            updateCoverFlowPositions();
        }
        
        function updateCoverFlowPositions() {
            if (cfItems.length === 0 || state.albumsCF.length === 0) {
                el.cfTitle.textContent = 'No Albums';
                el.cfTitle.classList.remove('scrolling');
                el.cfArtist.textContent = '';
                return;
            }
            
            const albumData = state.albumsCF[state.cfIdx];
            if (!albumData) return;
            
            // Reset e aggiorna marquee titolo (album name)
            el.cfTitle.classList.remove('scrolling');
            el.cfTitleWrapper.classList.remove('scrolling');
            el.cfTitle.style.removeProperty('--cf-scroll-offset');
            el.cfTitle.style.removeProperty('--cf-scroll-duration');
            el.cfTitle.textContent = albumData.album;
            el.cfArtist.textContent = albumData.artist || '';
            
            // Attiva marquee se il titolo supera il container
            requestAnimationFrame(() => {
                const titleWidth = el.cfTitle.scrollWidth;
                const wrapperWidth = el.cfTitleWrapper.clientWidth;
                const overflow = titleWidth - wrapperWidth;
                
                if (overflow > 5) {
                    // Add extra padding to ensure last char is fully visible
                    const offset = overflow + 30;
                    const pxPerSec = 30;
                    const duration = Math.max(4, Math.min(15, offset / pxPerSec));
                    el.cfTitle.style.setProperty('--cf-scroll-offset', `-${offset}px`);
                    el.cfTitle.style.setProperty('--cf-scroll-duration', `${duration}s`);
                    el.cfTitle.classList.add('scrolling');
                    el.cfTitleWrapper.classList.add('scrolling');
                }
            });
            
            // Aggiorna posizione di ogni copertina con animazione
            cfItems.forEach((item, i) => {
                const diff = i - state.cfIdx;
                
                // Reset classi
                item.className = 'coverflow-item';
                
                let transform, opacity, zIndex;
                
                if (diff === 0) {
                    // Centro
                    transform = 'translateX(0) translateZ(30px) rotateY(0deg) scale(1.1)';
                    opacity = 1;
                    zIndex = 100;
                    item.classList.add('center');
                } else if (diff < 0) {
                    // Sinistra
                    const absDiff = Math.abs(diff);
                    const x = -50 - (absDiff - 1) * 35;
                    const scale = Math.max(0.5, 0.85 - (absDiff - 1) * 0.12);
                    opacity = Math.max(0, 1 - absDiff * 0.25);
                    zIndex = 50 - absDiff * 10;
                    transform = `translateX(${x}px) translateZ(0) rotateY(55deg) scale(${scale})`;
                    
                    if (absDiff > 3) {
                        opacity = 0;
                    }
                } else {
                    // Destra
                    const absDiff = diff;
                    const x = 50 + (absDiff - 1) * 35;
                    const scale = Math.max(0.5, 0.85 - (absDiff - 1) * 0.12);
                    opacity = Math.max(0, 1 - absDiff * 0.25);
                    zIndex = 50 - absDiff * 10;
                    transform = `translateX(${x}px) translateZ(0) rotateY(-55deg) scale(${scale})`;
                    
                    if (absDiff > 3) {
                        opacity = 0;
                    }
                }
                
                item.style.transform = transform;
                item.style.opacity = opacity;
                item.style.zIndex = zIndex;
            });
        }
        
        // Aggiorna Cover Flow quando cambiano le canzoni
        function updateCoverFlow() {
            initCoverFlow();
        }
        
        // Drag per navigare nel Cover Flow
        function cfDragStart(e) {
            if (state.view !== 'coverflow' || state.albumsCF.length === 0) return;
            cfDrag.active = true;
            cfDrag.moved = false;
            cfDrag.startX = e.touches ? e.touches[0].clientX : e.clientX;
            cfDrag.startIdx = state.cfIdx;
        }
        
        function cfDragMove(e) {
            if (!cfDrag.active) return;
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const diff = cfDrag.startX - x;
            
            // Segna come moved solo se c'è movimento significativo
            if (Math.abs(diff) > 10) {
                cfDrag.moved = true;
            }
            
            const threshold = 35; // pixel per cambiare cover
            const steps = Math.round(diff / threshold);
            const newIdx = Math.max(0, Math.min(state.albumsCF.length - 1, cfDrag.startIdx + steps));
            
            if (newIdx !== state.cfIdx) {
                state.cfIdx = newIdx;
                state.cfTargetIdx = newIdx; // Sincronizza target
                tickSound();
                updateCoverFlowPositions();
            }
        }
        
        function cfDragEnd() {
            cfDrag.active = false;
            // Reset moved dopo un breve delay per permettere il click
            setTimeout(() => { cfDrag.moved = false; }, 50);
        }
        
        // Event listeners per drag Cover Flow
        el.coverflowContainer.addEventListener('mousedown', cfDragStart);
        el.coverflowContainer.addEventListener('touchstart', cfDragStart, { passive: true });
        document.addEventListener('mousemove', cfDragMove);
        document.addEventListener('touchmove', cfDragMove, { passive: true });
        document.addEventListener('mouseup', cfDragEnd);
        document.addEventListener('touchend', cfDragEnd);

        // ==================== LYRICS ====================
        // ==================== LYRICS SYSTEM ====================
        // Funzione di pulizia titolo per migliorare i risultati
        function cleanTitle(title) {
            return title
                .replace(/\(.*?\)/g, '')      // Rimuove (Remastered), (Live), etc.
                .replace(/\[.*?\]/g, '')      // Rimuove [Official Video], etc.
                .replace(/\s*-\s*\d{4}.*$/i, '') // Rimuove "- 2011 Remaster"
                .replace(/feat\..*$/i, '')    // Rimuove "feat. X"
                .replace(/ft\..*$/i, '')      // Rimuove "ft. X"
                .replace(/\s+/g, ' ')         // Normalizza spazi
                .trim();
        }
        
        function cleanArtist(artist) {
            return artist
                .replace(/feat\..*$/i, '')
                .replace(/ft\..*$/i, '')
                .replace(/&.*$/i, '')         // Rimuove "& Other Artist"
                .replace(/,.*$/i, '')         // Rimuove ", Other Artist"
                .trim();
        }
        
        // Fetch with timeout wrapper
        async function fetchWithTimeout(url, timeout = 8000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(id);
                return response;
            } catch (e) {
                clearTimeout(id);
                throw e;
            }
        }
        
        // Servizio 1: LRCLIB (primario - supporta testi sincronizzati)
        async function fetchLRCLIB(artist, title) {
            const cleanedTitle = cleanTitle(title);
            const cleanedArtist = cleanArtist(artist);
            
            // Prima prova con match esatto
            const url = `https://lrclib.net/api/get?artist_name=${encodeURIComponent(cleanedArtist)}&track_name=${encodeURIComponent(cleanedTitle)}`;
            
            try {
                const res = await fetchWithTimeout(url);
                if (res.ok) {
                    const data = await res.json();
                    if (data.plainLyrics) {
                        return {
                            lyrics: data.plainLyrics,
                            synced: data.syncedLyrics || null,
                            source: 'LRCLIB'
                        };
                    }
                }
            } catch (e) {
                // Continua con la ricerca
            }
            
            // Fallback: prova con ricerca più flessibile
            const searchUrl = `https://lrclib.net/api/search?q=${encodeURIComponent(cleanedArtist + ' ' + cleanedTitle)}`;
            const searchRes = await fetchWithTimeout(searchUrl);
            if (!searchRes.ok) throw new Error('LRCLIB: Search failed');
            
            const results = await searchRes.json();
            if (results && results.length > 0) {
                // Prendi il primo risultato che ha lyrics
                for (const result of results) {
                    if (result.plainLyrics) {
                        return {
                            lyrics: result.plainLyrics,
                            synced: result.syncedLyrics || null,
                            source: 'LRCLIB'
                        };
                    }
                }
            }
            throw new Error('LRCLIB: No lyrics found');
        }
        
        // Servizio 2: ChartLyrics (fallback - XML API)
        async function fetchChartLyrics(artist, title) {
            const cleanedTitle = cleanTitle(title);
            const cleanedArtist = cleanArtist(artist);
            
            // Prima cerca la canzone
            const searchUrl = `https://api.chartlyrics.com/apiv1.asmx/SearchLyricDirect?artist=${encodeURIComponent(cleanedArtist)}&song=${encodeURIComponent(cleanedTitle)}`;
            
            const res = await fetchWithTimeout(searchUrl);
            if (!res.ok) throw new Error('ChartLyrics: Search failed');
            
            const text = await res.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'text/xml');
            
            const lyricEl = xml.querySelector('Lyric');
            if (lyricEl && lyricEl.textContent && lyricEl.textContent.trim()) {
                return {
                    lyrics: lyricEl.textContent,
                    synced: null,
                    source: 'ChartLyrics'
                };
            }
            throw new Error('ChartLyrics: No lyrics found');
        }
        
        // Servizio 3: lyrics.ovh (secondo fallback) - con gestione errori migliorata
        async function fetchLyricsOvh(artist, title) {
            const cleanedTitle = cleanTitle(title);
            const cleanedArtist = cleanArtist(artist);
            
            const url = `https://api.lyrics.ovh/v1/${encodeURIComponent(cleanedArtist)}/${encodeURIComponent(cleanedTitle)}`;
            
            const res = await fetchWithTimeout(url, 10000); // Timeout più lungo per questo servizio
            if (!res.ok) throw new Error('lyrics.ovh: Request failed');
            
            const data = await res.json();
            
            if (data.lyrics && data.lyrics.trim()) {
                return {
                    lyrics: data.lyrics,
                    synced: null,
                    source: 'lyrics.ovh'
                };
            }
            throw new Error('lyrics.ovh: No lyrics found');
        }
        
        // ==================== KARAOKE SYSTEM ====================
        let syncedLyricsData = null; // Array di {time, text} per la canzone corrente
        let karaokeInterval = null;
        
        // Parsa il formato LRC: [mm:ss.xx] testo
        function parseLRC(lrcString) {
            const lines = lrcString.split('\n');
            const result = [];
            
            for (const line of lines) {
                // Match [mm:ss.xx] o [mm:ss]
                const match = line.match(/^\[(\d{2}):(\d{2})\.?(\d{0,2})\]\s*(.*)$/);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const centiseconds = match[3] ? parseInt(match[3].padEnd(2, '0'), 10) : 0;
                    const time = minutes * 60 + seconds + centiseconds / 100;
                    const text = match[4].trim();
                    
                    if (text) { // Solo righe con testo
                        result.push({ time, text });
                    }
                }
            }
            
            return result.sort((a, b) => a.time - b.time);
        }
        
        // Renderizza i testi sincronizzati (con escape per sicurezza)
        function renderSyncedLyrics(lyricsArray) {
            const html = lyricsArray.map((item, idx) => 
                `<div class="lyric-line" data-index="${idx}" data-time="${item.time}">${esc(item.text)}</div>`
            ).join('');
            
            el.lyricsContent.innerHTML = `<div class="lyrics-synced">${html}</div>`;
        }
        
        // Aggiorna la riga corrente durante la riproduzione
        let lastKaraokeActiveIndex = -1; // Track last active line to avoid unnecessary scrolls
        
        function updateKaraoke() {
            if (!syncedLyricsData || syncedLyricsData.length === 0) return;
            
            const currentTime = activeAudio.currentTime;
            let activeIndex = -1;
            
            // Trova la riga corrente
            for (let i = syncedLyricsData.length - 1; i >= 0; i--) {
                if (currentTime >= syncedLyricsData[i].time) {
                    activeIndex = i;
                    break;
                }
            }
            
            // Aggiorna le classi
            const lines = el.lyricsContent.querySelectorAll('.lyric-line');
            lines.forEach((line, idx) => {
                line.classList.toggle('active', idx === activeIndex);
                line.classList.toggle('past', idx < activeIndex);
            });
            
            // Auto-scroll alla riga attiva SOLO se è cambiata
            if (activeIndex >= 0 && activeIndex !== lastKaraokeActiveIndex) {
                lastKaraokeActiveIndex = activeIndex;
                const activeLine = lines[activeIndex];
                if (activeLine) {
                    activeLine.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
            }
        }
        
        function startKaraoke() {
            stopKaraoke();
            lastKaraokeActiveIndex = -1; // Reset on start
            if (syncedLyricsData && syncedLyricsData.length > 0) {
                karaokeInterval = setInterval(updateKaraoke, 100); // Aggiorna ogni 100ms
                updateKaraoke(); // Aggiorna subito
            }
        }
        
        function stopKaraoke() {
            if (karaokeInterval) {
                clearInterval(karaokeInterval);
                karaokeInterval = null;
            }
        }
        
        async function loadLyrics() {
            const songIdx = state.currentSong;
            const song = state.songs[songIdx];
            if (!song) {
                el.lyricsContent.innerHTML = '<div class="error">No song playing</div>';
                return;
            }
            
            const key = `${song.artist}-${song.title}`;
            const requestId = ++state.lyricsRequestId; // Track this request
            
            // Reset karaoke
            stopKaraoke();
            syncedLyricsData = null;
            
            // Helper to check if this request is still valid
            function isStale() {
                return requestId !== state.lyricsRequestId || state.currentSong !== songIdx;
            }
            
            // Cache check - verifica se abbiamo testi sincronizzati cachati
            if (state.syncedLyrics && state.syncedLyrics[key]) {
                if (isStale()) return;
                syncedLyricsData = parseLRC(state.syncedLyrics[key]);
                renderSyncedLyrics(syncedLyricsData);
                if (state.playing) startKaraoke();
                return;
            }
            
            // Cache check - testi normali
            if (state.lyrics[key]) {
                if (isStale()) return;
                el.lyricsContent.innerHTML = `<div class="lyrics-text">${state.lyrics[key]}</div>`;
                return;
            }
            
            // Helper per aggiornare lo stato
            function updateStatus(serviceName, step, total) {
                if (isStale()) return;
                const statusEl = el.lyricsContent.querySelector('.lyrics-status');
                if (statusEl) {
                    statusEl.textContent = `Trying ${serviceName}... (${step}/${total})`;
                }
            }
            
            const services = [
                { name: 'LRCLIB', fn: fetchLRCLIB },
                { name: 'ChartLyrics', fn: fetchChartLyrics },
                { name: 'lyrics.ovh', fn: fetchLyricsOvh }
            ];
            
            for (let i = 0; i < services.length; i++) {
                if (isStale()) return; // Cancel if song changed
                
                const service = services[i];
                try {
                    updateStatus(service.name, i + 1, services.length);
                    
                    const result = await service.fn(song.artist, song.title);
                    
                    // Check again after async operation
                    if (isStale()) return;
                    
                    if (result.lyrics) {
                        // Escape HTML first, then convert newlines to <br>
                        const escaped = esc(result.lyrics);
                        const formatted = escaped.replace(/\n/g, '<br>');
                        state.lyrics[key] = formatted;
                        
                        // Se ci sono testi sincronizzati (LRCLIB), usa il karaoke
                        if (result.synced) {
                            state.syncedLyrics = state.syncedLyrics || {};
                            state.syncedLyrics[key] = result.synced;
                            
                            syncedLyricsData = parseLRC(result.synced);
                            renderSyncedLyrics(syncedLyricsData);
                            if (state.playing) startKaraoke();
                        } else {
                            // Testi normali senza sync
                            el.lyricsContent.innerHTML = `<div class="lyrics-text">${formatted}</div>`;
                        }
                        return;
                    }
                } catch (e) {
                    console.log(`${service.name} failed:`, e.message);
                    continue;
                }
            }
            
            // Check one more time before showing "not found"
            if (isStale()) return;
            
            // Tutti i servizi hanno fallito
            el.lyricsContent.innerHTML = `
                <div class="lyrics-loading">
                    <div style="font-size: 32px; margin-bottom: 10px;">🎵</div>
                    <div>Lyrics not found</div>
                    <div class="lyrics-status">${esc(song.artist)} - ${esc(song.title)}</div>
                </div>
            `;
        }

        // ==================== FILE LOADING ====================
        const MAX_SONGS = 500; // Maximum number of songs
        
        el.fileInput.addEventListener('change', async (e) => {
            warmUpAudio();
            const files = [...e.target.files].filter(f => f.type.startsWith('audio/') || /\.(mp3|m4a|wav|ogg|flac)$/i.test(f.name));
            if (files.length) await loadFiles(files);
            e.target.value = '';
        });
        
        el.folderInput.addEventListener('change', async (e) => {
            warmUpAudio();
            const allFiles = [...e.target.files];
            const audioFiles = allFiles.filter(f => f.type.startsWith('audio/') || /\.(mp3|m4a|wav|ogg|flac)$/i.test(f.name));
            
            if (audioFiles.length === 0) {
                showToast('No audio files found in folder');
                e.target.value = '';
                return;
            }
            
            const available = MAX_SONGS - state.songs.length;
            const toLoad = audioFiles.slice(0, available);
            const skipped = audioFiles.length - toLoad.length;
            
            if (toLoad.length > 0) {
                await loadFiles(toLoad);
            }
            
            if (skipped > 0) {
                showToast(`Limit reached: ${skipped} songs not imported (max ${MAX_SONGS})`);
            }
            
            e.target.value = '';
        });
        
        async function loadFiles(files) {
            el.loadingOverlay.classList.add('active');
            el.loadingText.textContent = 'Loading songs...';
            
            const oldLength = state.songs.length;
            
            // Determine concurrency based on device capabilities
            const maxConcurrency = Math.min(
                navigator.hardwareConcurrency || 4,
                8 // Cap at 8 to avoid overwhelming the browser
            );
            
            let completed = 0;
            const total = files.length;
            const queue = [...files];
            const results = [];
            
            // Update progress
            const updateProgress = () => {
                el.loadingProgress.textContent = `${completed} of ${total}`;
            };
            updateProgress();
            
            // Process files in parallel with concurrency limit
            async function processQueue() {
                while (queue.length > 0) {
                    const file = queue.shift();
                    if (!file) break;
                    
                    const song = await loadFileFast(file);
                    if (song) {
                        results.push(song);
                    }
                    completed++;
                    updateProgress();
                }
            }
            
            // Start multiple workers
            const workers = [];
            for (let i = 0; i < maxConcurrency; i++) {
                workers.push(processQueue());
            }
            
            // Wait for all workers to complete
            await Promise.all(workers);
            
            // Add all loaded songs to state
            state.songs.push(...results);
            
            el.loadingOverlay.classList.remove('active');
            updateSongsList();
            
            const newLength = state.songs.length;
            const newSongIndices = [];
            for (let i = oldLength; i < newLength; i++) {
                newSongIndices.push(i);
            }
            
            // Handle playback list update
            if (state.playbackList.length === 0 && state.songs.length > 0) {
                // First load - initialize everything
                state.playbackContext = 'all';
                state.playbackList = state.songs.map((_, i) => i);
                if (state.shuffle) genContextShuffleQueue();
            } else if (newSongIndices.length > 0 && state.playbackContext === 'all') {
                // Adding songs to existing library in 'all' context
                // Append new indices to playbackList
                state.playbackList.push(...newSongIndices);
                
                // If shuffle is active, insert new songs randomly in FUTURE positions only
                if (state.shuffle && state.shuffleQueue.length > 0) {
                    newSongIndices.forEach(idx => {
                        // Insert at random position AFTER current shufflePos
                        const futureStart = state.shufflePos + 1;
                        const futureLength = state.shuffleQueue.length - futureStart;
                        if (futureLength > 0) {
                            const randomPos = futureStart + Math.floor(Math.random() * (futureLength + 1));
                            state.shuffleQueue.splice(randomPos, 0, idx);
                        } else {
                            // Just append if we're at the end
                            state.shuffleQueue.push(idx);
                        }
                    });
                }
            }
        }
        
        // Faster file loader using Blob URLs for artwork
        function loadFileFast(file) {
            return new Promise(resolve => {
                let finished = false;
                
                const song = {
                    file,
                    url: URL.createObjectURL(file),
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: '',
                    album: '',
                    artwork: null,
                    searched: false
                };
                
                function finalize() {
                    if (finished) return;
                    finished = true;
                    resolve(song);
                }
                
                // Shorter timeout for faster processing on mobile
                const timeout = setTimeout(() => {
                    searchMetadata(song, file.name);
                    finalize();
                }, 2000);
                
                try {
                    jsmediatags.read(file, {
                        onSuccess: (tag) => {
                            clearTimeout(timeout);
                            if (finished) return;
                            
                            const t = tag.tags;
                            if (t.title) song.title = t.title;
                            if (t.artist) song.artist = t.artist;
                            if (t.album) song.album = t.album;
                            
                            // Use Blob URL for artwork (faster than base64)
                            if (t.picture) {
                                try {
                                    const { data, format } = t.picture;
                                    const blob = new Blob([new Uint8Array(data)], { type: format });
                                    song.artwork = URL.createObjectURL(blob);
                                } catch (e) {
                                    console.log('Artwork extraction failed:', e);
                                }
                            }
                            
                            if (!song.artist) searchMetadata(song, file.name);
                            finalize();
                        },
                        onError: () => {
                            clearTimeout(timeout);
                            if (finished) return;
                            searchMetadata(song, file.name);
                            finalize();
                        }
                    });
                } catch (e) {
                    clearTimeout(timeout);
                    if (finished) return;
                    searchMetadata(song, file.name);
                    finalize();
                }
            });
        }
        
        // Legacy loadFile for backward compatibility
        async function loadFile(file) {
            return loadFileFast(file).then(song => {
                if (song) state.songs.push(song);
            });
        }
        
        async function searchMetadata(song, filename) {
            try {
                let searchTerm = filename
                    .replace(/\.[^/.]+$/, '')
                    .replace(/[\[\(].*?[\]\)]/g, '')
                    .replace(/[_\-]/g, ' ')
                    .replace(/\d{2,}/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                if (searchTerm.length < 3) return;
                
                const response = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=5`);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const best = data.results[0];
                    if (!song.artist) song.artist = best.artistName;
                    if (!song.album) song.album = best.collectionName;
                    if (!song.artwork) song.artwork = best.artworkUrl100.replace('100x100', '300x300');
                    if (song.title === filename.replace(/\.[^/.]+$/, '')) song.title = best.trackName;
                }
            } catch (e) {}
        }

        // ==================== DRAG & DROP ====================
        let dragCount = 0;
        
        document.body.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCount++;
            if (e.dataTransfer.types.includes('Files')) {
                el.dropZone.classList.add('active');
            }
        });
        
        document.body.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCount--;
            if (dragCount === 0) el.dropZone.classList.remove('active');
        });
        
        document.body.addEventListener('dragover', (e) => e.preventDefault());
        
        document.body.addEventListener('drop', async (e) => {
            e.preventDefault();
            warmUpAudio();
            dragCount = 0;
            el.dropZone.classList.remove('active');
            
            const files = [...e.dataTransfer.files].filter(f => f.type.startsWith('audio/') || /\.(mp3|m4a|wav|ogg|flac)$/i.test(f.name));
            if (files.length) await loadFiles(files);
        });

        // ==================== PLAYBACK ====================
        // Start playback with a context (playlist, album, artist, queue, all)
        function startPlayback(songIndices, startIdx, context = 'all') {
            state.playbackContext = context;
            state.playbackList = songIndices.slice(); // Copy the list
            state.playbackIdx = startIdx;
            
            // Generate shuffle queue for this context if shuffle is on
            if (state.shuffle) {
                genContextShuffleQueue();
                // CRITICAL: Move the selected track to position 0 in shuffleQueue
                // This ensures NEXT will play a different track
                const currentPosInShuffle = state.shuffleQueue.indexOf(startIdx);
                if (currentPosInShuffle > 0) {
                    // Swap with position 0
                    [state.shuffleQueue[0], state.shuffleQueue[currentPosInShuffle]] = 
                    [state.shuffleQueue[currentPosInShuffle], state.shuffleQueue[0]];
                }
                state.shufflePos = 0;
            }
            
            playSongFromContext(startIdx);
        }
        
        function genContextShuffleQueue() {
            // Create shuffle queue based on playback list
            state.shuffleQueue = [...Array(state.playbackList.length).keys()];
            for (let i = state.shuffleQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [state.shuffleQueue[i], state.shuffleQueue[j]] = [state.shuffleQueue[j], state.shuffleQueue[i]];
            }
            state.shufflePos = 0;
        }
        
        function playSongFromContext(contextIdx) {
            if (contextIdx < 0 || contextIdx >= state.playbackList.length) return;
            
            state.playbackIdx = contextIdx;
            
            // Sync shufflePos if shuffle is active
            if (state.shuffle && state.shuffleQueue.length > 0) {
                const sp = state.shuffleQueue.indexOf(contextIdx);
                if (sp !== -1) {
                    state.shufflePos = sp;
                }
            }
            
            const songIdx = state.playbackList[contextIdx];
            
            playSongDirect(songIdx);
        }
        
        function playSongDirect(idx) {
            if (idx < 0 || idx >= state.songs.length) return;
            
            // Cancel any active crossfade
            cancelCrossfade();
            
            // Reset karaoke per la nuova canzone
            stopKaraoke();
            syncedLyricsData = null;
            
            // Clean up inactiveAudio
            try { inactiveAudio.pause(); } catch (e) {}
            inactiveAudio.src = '';
            try { inactiveAudio.currentTime = 0; } catch (e) {}
            
            state.currentSong = idx;
            const song = state.songs[idx];
            
            // Set src FIRST, then update MediaSession
            activeAudio.src = song.url;
            activeAudio.volume = state.volume;
            
            // Update MediaSession metadata (but position will be updated after loadedmetadata)
            try { if (window.__pwaUpdateMediaSessionMetadataOnly) window.__pwaUpdateMediaSessionMetadataOnly(idx); } catch (e) {}
            
            activeAudio.play().then(() => {
                console.log('Playing:', song.title);
            }).catch((err) => {
                // Ignore "interrupted" errors from rapid track changes
                if (err.name === 'AbortError' || err.message?.includes('interrupted')) {
                    return;
                }
                console.error('Playback error:', err);
                if (!webAudioReady && audioCtx) {
                    setupAudioAnalyser();
                    activeAudio.play().catch(() => {}); // Silent retry
                }
            });
            state.playing = true;
            
            if (!song.artwork && !song.searched) {
                song.searched = true;
                fetchArtwork(song);
            }
            
            updateNowPlaying();
            updateSongsList();
        }
        
        // Legacy playSong for backward compatibility - plays in 'all songs' context
        function playSong(idx) {
            if (state.playbackList.length === 0 || state.playbackContext === 'all') {
                // Default to all songs context
                state.playbackContext = 'all';
                state.playbackList = state.songs.map((_, i) => i);
                state.playbackIdx = idx;
                
                if (state.shuffle) {
                    genContextShuffleQueue();
                }
            } else {
                // Find the song in the current playback list
                const contextIdx = state.playbackList.indexOf(idx);
                if (contextIdx !== -1) {
                    state.playbackIdx = contextIdx;
                }
            }
            
            playSongDirect(idx);
        }
        
        function updateNowPlaying() {
            const song = state.songs[state.currentSong];
            
            // Update shuffle/repeat status icons using SVG icons
            let statusIcons = '';
            if (state.shuffle) statusIcons += '<span class="status-icon icon-shuffle"></span>';
            if (state.repeat === 'one') statusIcons += '<span class="status-icon icon-repeat-one"></span>';
            else if (state.repeat === 'all') statusIcons += '<span class="status-icon icon-repeat"></span>';
            el.npStatusIcons.innerHTML = statusIcons;
            
            if (!song) {
                el.npHeader.textContent = '0 of 0';
                el.trackTitleText.textContent = 'No Song';
                el.trackArtist.textContent = '';
                el.trackAlbum.textContent = '';
                el.albumArt.innerHTML = '<span class="no-art">♫</span>';
                el.playStatus.textContent = '';
                el.equalizer.classList.remove('active');
                document.title = 'iPod Classic 5.5G';
                return;
            }
            
            // Update window title with current song
            document.title = `${song.title} - ${song.artist || 'Unknown Artist'} | iPod`;
            
            // Show position within playback context
            const listSize = state.playbackList.length || state.songs.length;
            const position = state.playbackIdx + 1;
            el.npHeader.textContent = `${position} of ${listSize}`;
            
            el.trackTitleText.textContent = song.title;
            el.trackArtist.textContent = song.artist;
            el.trackAlbum.textContent = song.album;
            
            if (song.artwork) {
                el.albumArt.innerHTML = `<img src="${song.artwork}" alt="">`;
            } else {
                el.albumArt.innerHTML = '<span class="no-art">♫</span>';
            }
            
            // Only show play/pause icon if a song is loaded
            el.playStatus.textContent = state.playing ? '▶' : '❚❚';
            el.equalizer.classList.toggle('active', state.playing);
            requestAnimationFrame(updateTitleMarquee);
        }
        
        function updateTitleMarquee() {
            const container = el.trackTitle;
            const text = el.trackTitleText;
            if (!container || !text) return;

            container.classList.remove('marquee');
            container.style.removeProperty('--marquee-distance');
            container.style.removeProperty('--marquee-duration');

            // Force reflow to restart CSS animation cleanly
            void container.offsetWidth;

            if (!state.playing) return;

            const overflow = text.scrollWidth - container.clientWidth;
            if (overflow <= 2) return;

            const distance = overflow + 22;
            const pxPerSec = 35;
            let duration = distance / pxPerSec;
            duration = Math.max(4, Math.min(18, duration));

            container.style.setProperty('--marquee-distance', distance + 'px');
            container.style.setProperty('--marquee-duration', duration.toFixed(2) + 's');
            container.classList.add('marquee');
        }
        
        async function fetchArtwork(song) {
            // Robust artwork fetcher with retry logic
            const maxRetries = 2;
            const timeout = 8000; // 8 seconds timeout
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    const q = encodeURIComponent(`${song.artist} ${song.album || song.title}`);
                    const url = `https://itunes.apple.com/search?term=${q}&entity=album&limit=5`;
                    
                    // Use AbortController for timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const res = await fetch(url, {
                        signal: controller.signal,
                        cache: 'default',
                        mode: 'cors'
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!res.ok) {
                        console.log(`[fetchArtwork] HTTP ${res.status} for "${song.title}", attempt ${attempt + 1}`);
                        if (attempt < maxRetries) {
                            await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
                            continue;
                        }
                        throw new Error(`HTTP ${res.status}`);
                    }
                    
                    const data = await res.json();
                    
                    if (data.results && data.results.length > 0) {
                        // Try to find best match by artist name
                        let bestMatch = data.results[0];
                        const artistLower = (song.artist || '').toLowerCase();
                        for (const result of data.results) {
                            if (result.artistName && result.artistName.toLowerCase().includes(artistLower)) {
                                bestMatch = result;
                                break;
                            }
                        }
                        
                        // Get higher resolution artwork (600x600)
                        const art = bestMatch.artworkUrl100.replace('100x100', '600x600');
                        song.artwork = art;
                        
                        console.log(`[fetchArtwork] Found artwork for "${song.title}"`);
                        
                        // Update album-based CoverFlow if artwork was missing
                        updateCoverFlowArtwork(song.artist, song.album, art);
                        
                        if (state.songs[state.currentSong] === song) {
                            el.albumArt.innerHTML = `<img src="${art}" alt="">`;
                            // Update MediaSession with new artwork
                            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(state.currentSong); } catch (e) {}
                        }
                        return; // Success
                    } else {
                        console.log(`[fetchArtwork] No results for "${song.title}"`);
                    }
                    return; // No results but request succeeded
                    
                } catch (e) {
                    if (e.name === 'AbortError') {
                        console.log(`[fetchArtwork] Timeout for "${song.title}", attempt ${attempt + 1}`);
                    } else {
                        console.log(`[fetchArtwork] Error for "${song.title}":`, e.message);
                    }
                    
                    if (attempt < maxRetries) {
                        await new Promise(r => setTimeout(r, 1000 * (attempt + 1)));
                        continue;
                    }
                    
                    // Reset searched flag on final failure to allow retry later
                    song.searched = false;
                }
            }
        }
        
        // Update CoverFlow item when artwork is fetched
        function updateCoverFlowArtwork(artist, album, artworkUrl) {
            if (!state.albumsCF || state.albumsCF.length === 0) return;
            
            const albumIdx = state.albumsCF.findIndex(a => 
                a.artist === artist && a.album === album
            );
            
            if (albumIdx !== -1) {
                state.albumsCF[albumIdx].artwork = artworkUrl;
                
                // Update DOM if cfItems exists
                if (typeof cfItems !== 'undefined' && cfItems[albumIdx]) {
                    cfItems[albumIdx].innerHTML = `<img src="${artworkUrl}" alt="">`;
                }
            }
        }
        
        // Auto-fetch missing artworks for CoverFlow albums
        async function fetchMissingCoverFlowArtworks() {
            if (!state.albumsCF || state.albumsCF.length === 0) return;
            
            const albumsNeedingArt = state.albumsCF.filter(a => !a.artwork);
            
            // Limit concurrent requests
            const batchSize = 3;
            for (let i = 0; i < albumsNeedingArt.length; i += batchSize) {
                const batch = albumsNeedingArt.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (albumData) => {
                    // Check if any song in this album hasn't been searched yet
                    const firstSongIdx = albumData.songIndices[0];
                    const song = state.songs[firstSongIdx];
                    
                    if (song && !song.searched) {
                        song.searched = true;
                        await fetchArtwork(song);
                    }
                }));
                
                // Small delay between batches to avoid rate limiting
                if (i + batchSize < albumsNeedingArt.length) {
                    await new Promise(r => setTimeout(r, 300));
                }
            }
        }
        
        function togglePlay() {
            if (state.currentSong === -1 && state.songs.length > 0) {
                playSong(0);
                if (state.view !== 'nowplaying' && state.view !== 'lyrics' && state.view !== 'coverflow') {
                    navigateTo('nowplaying');
                }
                return;
            }

            if (state.currentSong === -1) return;

            if (state.playing) {
                // Pause during an active crossfade: pause BOTH tracks and freeze fade progress.
                if (crossfadeActive) {
                    crossfadePaused = true;
                    if (crossfadeInterval) {
                        clearInterval(crossfadeInterval);
                        crossfadeInterval = null;
                    }
                    try { activeAudio.pause(); } catch (e) {}
                    try { inactiveAudio.pause(); } catch (e) {}
                    return;
                }
                activeAudio.pause();
            } else {
                // Resume a paused crossfade exactly from the same point in the fade + audio positions.
                if (crossfadeActive && crossfadePaused && crossfadeState) {
                    crossfadePaused = false;
                    
                    // Capture session ID to detect if crossfade was cancelled during async operations
                    const mySession = crossfadeSession;

                    let pA = null;
                    let pB = null;
                    try { pA = activeAudio.play(); } catch (e) {}
                    try { pB = inactiveAudio.play(); } catch (e) {}

                    Promise.allSettled([pA, pB]).then(() => {
                        // Check if crossfade was cancelled while waiting for play() promises
                        if (mySession !== crossfadeSession) return;
                        if (!crossfadeActive || crossfadePaused || !crossfadeState) return;
                        if (activeAudio.paused || inactiveAudio.paused) return;

                        if (crossfadeInterval) {
                            clearInterval(crossfadeInterval);
                            crossfadeInterval = null;
                        }

                        crossfadeInterval = setInterval(() => {
                            if (!crossfadeActive || crossfadePaused || !crossfadeState || mySession !== crossfadeSession) {
                                if (crossfadeInterval) { clearInterval(crossfadeInterval); crossfadeInterval = null; }
                                return;
                            }

                            crossfadeState.step++;
                            const progress = crossfadeState.step / crossfadeState.fadeSteps;
                            const eased = progress * progress * (3 - 2 * progress);
                            activeAudio.volume = state.volume * (1 - eased);
                            inactiveAudio.volume = state.volume * eased;

                            if (crossfadeState.step >= crossfadeState.fadeSteps) {
                                completeCrossfade(crossfadeState.nextIdx);
                            }
                        }, crossfadeState.fadeInterval);
                    });

                    return;
                }

                activeAudio.play().catch(() => {});
            }
        }
        
        function syncPlaybackCursor() {
            if (!state.playbackList || state.playbackList.length === 0) return;
            const ctxIdx = state.playbackList.indexOf(state.currentSong);
            if (ctxIdx !== -1) {
                state.playbackIdx = ctxIdx;
                if (state.shuffle && Array.isArray(state.shuffleQueue) && state.shuffleQueue.length > 0) {
                    const sp = state.shuffleQueue.indexOf(ctxIdx);
                    if (sp !== -1) state.shufflePos = sp;
                }
            }
        }

        function nextTrack() {
            if (state.playbackList.length === 0) return false;
            
            // Cancel any active crossfade when manually changing tracks
            cancelCrossfade();
            // Re-sync playback cursor to current song (prevents context skip failures)
            syncPlaybackCursor();
            
            // Check queue first
            if (state.queue.length > 0) {
                const nextIdx = state.queue.shift();
                playSongDirect(nextIdx);
                reloadLyricsIfNeeded();
                return true;
            }
            
            let nextContextIdx;
            if (state.shuffle) {
                state.shufflePos++;
                if (state.shufflePos >= state.shuffleQueue.length) {
                    if (state.repeat === 'all') {
                        genContextShuffleQueue();
                        state.shufflePos = 0;
                    } else return false; // End of playlist
                }
                nextContextIdx = state.shuffleQueue[state.shufflePos];
            } else {
                nextContextIdx = state.playbackIdx + 1;
                if (nextContextIdx >= state.playbackList.length) {
                    if (state.repeat === 'all') nextContextIdx = 0;
                    else return false; // End of playlist
                }
            }
            
            playSongFromContext(nextContextIdx);
            reloadLyricsIfNeeded();
            return true;
        }
        
        function reloadLyricsIfNeeded() {
            if (state.view === 'lyrics') {
                // Cancel any pending lyrics request
                state.lyricsRequestId++;
                
                // Show loading immediately
                el.lyricsContent.innerHTML = `
                    <div class="lyrics-loading">
                        <div class="lyrics-spinner"></div>
                        <div class="lyrics-progress-bar">
                            <div class="lyrics-progress-fill"></div>
                        </div>
                        <div>Searching lyrics...</div>
                        <div class="lyrics-status">Loading...</div>
                    </div>
                `;
                
                // Load lyrics after a brief delay to ensure UI updates
                requestAnimationFrame(() => {
                    loadLyrics();
                });
            }
            // Don't automatically navigate to nowplaying - let user stay in menus
        }
        
        function prevTrack() {
            if (state.playbackList.length === 0) return;
            
            // Cancel any active crossfade
            cancelCrossfade();
            // Re-sync playback cursor to current song (prevents context skip failures)
            syncPlaybackCursor();
            
            if (activeAudio.currentTime > 3) {
                activeAudio.currentTime = 0;
                return;
            }
            
            let prevContextIdx;
            if (state.shuffle) {
                state.shufflePos--;
                if (state.shufflePos < 0) { state.shufflePos = 0; return; }
                prevContextIdx = state.shuffleQueue[state.shufflePos];
            } else {
                prevContextIdx = state.playbackIdx - 1;
                if (prevContextIdx < 0) {
                    prevContextIdx = state.repeat === 'all' ? state.playbackList.length - 1 : 0;
                }
            }
            
            playSongFromContext(prevContextIdx);
            reloadLyricsIfNeeded();
        }
        
        function shufflePlay() {
            if (!state.songs.length) return;
            state.shuffle = true;
            
            // Start playback with all songs in shuffle mode
            const allSongIndices = state.songs.map((_, i) => i);
            state.playbackContext = 'all';
            state.playbackList = allSongIndices;
            genContextShuffleQueue();
            
            playSongFromContext(state.shuffleQueue[0]);
            navigateTo('nowplaying');
            updateSettings();
            saveState();
        }
        
        // Legacy genShuffleQueue for compatibility
        function genShuffleQueue() {
            genContextShuffleQueue();
        }

        // ==================== PROGRESS BAR & SCRUBBER ====================
        let scrubbing = false;
        
        function updateProgress(clientX) {
            if (!activeAudio.duration || isNaN(activeAudio.duration) || activeAudio.duration === 0) return;
            const rect = el.progressBar.getBoundingClientRect();
            if (rect.width === 0) return;
            const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
            const newTime = ratio * activeAudio.duration;
            if (!isNaN(newTime) && isFinite(newTime)) {
                activeAudio.currentTime = newTime;
            }
        }
        
        el.progressBar.addEventListener('mousedown', (e) => {
            if (!activeAudio.duration || activeAudio.duration === 0) return;
                        if (crossfadeActive) cancelCrossfade();
e.preventDefault();
            e.stopPropagation();
            scrubbing = true;
            el.progressScrubber.classList.add('dragging');
            updateProgress(e.clientX);
        });
        
        el.progressBar.addEventListener('touchstart', (e) => {
            if (!activeAudio.duration || activeAudio.duration === 0) return;
                        if (crossfadeActive) cancelCrossfade();
e.stopPropagation();
            scrubbing = true;
            el.progressScrubber.classList.add('dragging');
            if (e.touches[0]) updateProgress(e.touches[0].clientX);
        }, { passive: true });
        
        // Also handle click for single tap
        el.progressBar.addEventListener('click', (e) => {
            if (!activeAudio.duration || activeAudio.duration === 0) return;
                        if (crossfadeActive) cancelCrossfade();
e.preventDefault();
            e.stopPropagation();
            updateProgress(e.clientX);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (scrubbing) {
                e.preventDefault();
                updateProgress(e.clientX);
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (scrubbing && e.touches[0]) {
                updateProgress(e.touches[0].clientX);
            }
        }, { passive: true });
        
        document.addEventListener('mouseup', () => {
            if (scrubbing) {
                scrubbing = false;
                el.progressScrubber.classList.remove('dragging');
            }
        });
        
        document.addEventListener('touchend', () => {
            if (scrubbing) {
                scrubbing = false;
                el.progressScrubber.classList.remove('dragging');
            }
        });

        // ==================== AUDIO EVENTS ====================
        // Handler functions that can be used by both audio elements
        function onAudioError(e) {
            const a = e.target;
            // Only handle errors for active audio
            if (a !== activeAudio) return;
            
            const err = a.error;
            const codes = {
                1: 'MEDIA_ERR_ABORTED - Fetch aborted',
                2: 'MEDIA_ERR_NETWORK - Network error',
                3: 'MEDIA_ERR_DECODE - Decode error (format not supported)',
                4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - Source not supported'
            };
            console.error('Audio error:', codes[err?.code] || err);
            alert('Playback error: ' + (codes[err?.code] || 'Unknown error'));
        }
        
        function onAudioTimeUpdate(e) {
            const a = e.target;
            // Keep MediaSession position in sync (notifications/lockscreen)
            try { if (window.__pwaUpdateMediaSessionPosition) window.__pwaUpdateMediaSessionPosition(); } catch (e) {}
            // Only update UI for active audio
            if (a !== activeAudio) return;
            
            if (activeAudio.duration && !scrubbing) {
                try { el.progressBar.classList.toggle('scrub-active', !!state.npScrubActive); } catch (e) {}
                // In Now Playing scrub mode we keep the UI running (seconds keep moving),
                // while still allowing clickwheel seeking.
                if (state.npScrubActive && isFinite(activeAudio.currentTime)) {
                    state.npScrubTarget = activeAudio.currentTime;
                }
                const pct = (activeAudio.currentTime / activeAudio.duration) * 100;
                el.progressFill.style.width = pct + '%';
                el.currentTime.textContent = fmt(activeAudio.currentTime);
                el.remainingTime.textContent = '-' + fmt(activeAudio.duration - activeAudio.currentTime);
                
                // Crossfade: start fading when near end
                if (state.crossfade > 0 && activeAudio.duration > 0) {
                    const timeLeft = activeAudio.duration - activeAudio.currentTime;
                    if (timeLeft <= state.crossfade && timeLeft > 0 && !crossfadeActive) {
                        startCrossfade();
                    }
                }
            }
        }
        
        // Attach handlers to both audio elements
        audio.addEventListener('error', onAudioError);
        audio2.addEventListener('error', onAudioError);
        audio.addEventListener('timeupdate', onAudioTimeUpdate);
        audio2.addEventListener('timeupdate', onAudioTimeUpdate);
        
        // Crossfade support
        let crossfadeActive = false;
        
            let crossfadeInterval = null;
        
        let crossfadePaused = false;
        let crossfadeState = null; // { nextIdx, fadeSteps, fadeInterval, step }
        let crossfadeSession = 0; // increments to invalidate pending crossfade async work
        let crossfadePrepPromise = null;
        
        function cancelCrossfade() {
            // Invalidate any pending crossfade async work
            crossfadeSession++;
            if (crossfadeInterval) {
                clearInterval(crossfadeInterval);
                crossfadeInterval = null;
            }
            crossfadePaused = false;
            crossfadeState = null;
            crossfadePrepPromise = null;
            if (crossfadeActive) {
                try { inactiveAudio.pause(); } catch (e) {}
                inactiveAudio.src = '';
                try { inactiveAudio.currentTime = 0; } catch (e) {}
                activeAudio.volume = state.volume;
                crossfadeActive = false;
            }
            // If we had already switched MediaSession metadata to the incoming track, restore it.
            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(state.currentSong); } catch (e) {}
            try { if (window.__pwaUpdateMediaSessionPosition) window.__pwaUpdateMediaSessionPosition(true); } catch (e) {}
        }

        function completeCrossfade(nextIdx) {
            if (crossfadeInterval) {
                clearInterval(crossfadeInterval);
                crossfadeInterval = null;
            }

            // SWAP POINTERS - this is the key to seamless transition!
            // inactiveAudio is already playing the new song, just swap who is "active"
            const oldActive = activeAudio;
            activeAudio = inactiveAudio;
            inactiveAudio = oldActive;

            // Now stop the OLD element (which is now inactiveAudio)
            try { inactiveAudio.pause(); } catch (e) {}
            inactiveAudio.src = '';
            try { inactiveAudio.currentTime = 0; } catch (e) {}

            // Update state and UI
            state.currentSong = nextIdx;

            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(nextIdx); } catch (e) {}
            // Sync playback indices (so "X of Y" updates correctly)
            if (state.queue.length > 0) {
                state.queue.shift();
            }

            const ctxIdx = state.playbackList.indexOf(nextIdx);
            if (ctxIdx !== -1) {
                state.playbackIdx = ctxIdx;
                if (state.shuffle) {
                    const sp = state.shuffleQueue.indexOf(ctxIdx);
                    if (sp !== -1) state.shufflePos = sp;
                }
            }

            // Keep CoverFlow selection in sync only while the user is actually in Cover Flow.
            if (state.view === 'coverflow') {
                state.cfIdx = nextIdx;
                state.cfTargetIdx = nextIdx;
            }
            // Reset karaoke/lyrics state for the new track
            stopKaraoke();
            syncedLyricsData = null;

            // Trigger artwork fetch like playSongDirect would
            const newSong = state.songs[nextIdx];
            if (newSong && !newSong.artwork && !newSong.searched) {
                newSong.searched = true;
                fetchArtwork(newSong);
            }

            updateNowPlaying();
            updateSongsList();
            if (state.view === 'coverflow') {
                updateCoverFlowPositions();
            }
            reloadLyricsIfNeeded();

            // Restore proper volume on the now-active element
            activeAudio.volume = state.volume;

            crossfadePaused = false;
            crossfadeState = null;
            crossfadePrepPromise = null;
            crossfadeActive = false;
        }
        
        function startCrossfade() {
            if (crossfadeActive || state.repeat === 'one') return;
            crossfadeActive = true;
            crossfadePaused = false;
            // Session token to prevent race conditions when user skips during crossfade
            const mySession = ++crossfadeSession;

            // Get next song index
            let nextIdx = getNextTrackIndex();
            if (nextIdx === -1) {
                crossfadeActive = false;
                return;
            }

            const nextSong = state.songs[nextIdx];
            if (!nextSong) {
                crossfadeActive = false;
                return;
            }


            // Prefetch artwork early for better UI responsiveness
            if (!nextSong.artwork && !nextSong.searched) {
                nextSong.searched = true;
                fetchArtwork(nextSong);
            }

            // If user is in Cover Flow, keep selection in sync as soon as the new track starts fading in
            if (state.view === 'coverflow') {
                state.cfIdx = nextIdx;
                state.cfTargetIdx = nextIdx;
                try { updateCoverFlowPositions(); } catch (e) {}
            }
            // Prepare inactiveAudio for crossfade (do NOT restart it at the end)
            inactiveAudio.src = nextSong.url;
            try { inactiveAudio.currentTime = 0; } catch (e) {}
            inactiveAudio.volume = 0;

            const fadeSteps = 30;
            const fadeInterval = Math.max(20, Math.floor((state.crossfade * 1000) / fadeSteps));
            crossfadeState = { nextIdx, fadeSteps, fadeInterval, step: 0 };

            // Update MediaSession immediately so notification/lockscreen shows the incoming track
            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(nextIdx); } catch (e) {}

            // Start playing inactiveAudio, then fade
            crossfadePrepPromise = inactiveAudio.play();

            crossfadePrepPromise.then(() => {
                // If the user skipped/seeked/cancelled while inactiveAudio was starting, abort cleanly
                if (!crossfadeActive || crossfadePaused || !crossfadeState || mySession !== crossfadeSession) {
                    if (crossfadeInterval) { clearInterval(crossfadeInterval); crossfadeInterval = null; }
                    try { inactiveAudio.pause(); } catch (e) {}
                    return;
                }

                if (crossfadeInterval) {
                    clearInterval(crossfadeInterval);
                    crossfadeInterval = null;
                }

                crossfadeInterval = setInterval(() => {
                    if (!crossfadeActive || crossfadePaused || !crossfadeState) return;

                    crossfadeState.step++;
                    const progress = crossfadeState.step / crossfadeState.fadeSteps;
                    // Smoothstep easing for natural fade
                    const eased = progress * progress * (3 - 2 * progress);
                    activeAudio.volume = state.volume * (1 - eased);
                    inactiveAudio.volume = state.volume * eased;

                    if (crossfadeState.step >= crossfadeState.fadeSteps) {
                        completeCrossfade(crossfadeState.nextIdx);
                    }
                }, crossfadeState.fadeInterval);
            }).catch(() => {
                // If next track can't start, abort crossfade
                cancelCrossfade();
            });
        }
        
        function getNextTrackIndex() {
            // Check queue first
            if (state.queue.length > 0) {
                return state.queue[0]; // Don't shift yet, will be done in nextTrack
            }
            
            if (state.playbackList.length === 0) return -1;
            
            if (state.shuffle) {
                const nextPos = state.shufflePos + 1;
                if (nextPos >= state.shuffleQueue.length) {
                    if (state.repeat === 'all') {
                        return state.playbackList[state.shuffleQueue[0]];
                    }
                    return -1;
                }
                return state.playbackList[state.shuffleQueue[nextPos]];
            } else {
                const nextContextIdx = state.playbackIdx + 1;
                if (nextContextIdx >= state.playbackList.length) {
                    if (state.repeat === 'all') return state.playbackList[0];
                    return -1;
                }
                return state.playbackList[nextContextIdx];
            }
        }
        
        function onAudioEnded(e) {
            const a = e.target;
            // Only handle ended for active audio
            if (a !== activeAudio) return;
            
            // If crossfade handled it, skip
            if (crossfadeActive) return;
            
            if (state.repeat === 'one') {
                activeAudio.currentTime = 0;
                activeAudio.play().catch(() => {});
            } else {
                const hasNext = nextTrack();
                // If no next track (end of playlist without repeat), return to main menu
                if (!hasNext) {
                    state.playing = false;
                    state.currentSong = -1;
                    updateNowPlaying();
                    // Navigate to main menu
                    state.history = ['menu'];
                    showView('menu', 'back');
                }
            }
        }
        
        function onAudioPlay(e) {
            const a = e.target;
            // Only update state for active audio
            if (a !== activeAudio) return;
            
            // Update state FIRST before notifying MediaSession
            state.playing = true;
            
            // Now notify MediaSession with correct state
            try { if (window.__pwaStartPositionUpdates) window.__pwaStartPositionUpdates(); } catch (e) {}
            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(state.currentSong); } catch (e) {}
            
            // Only show play icon if a song is loaded
            if (state.currentSong >= 0) {
                el.playStatus.textContent = '▶';
            }
            el.equalizer.classList.add('active');
            startVisualEQ();
            // Only start karaoke if actually in lyrics view
            if (state.view === 'lyrics') {
                startKaraoke();
            }
            requestAnimationFrame(updateTitleMarquee);
        }
        
        function onAudioPause(e) {
            const a = e.target;
            // Only update state for active audio.
            // Ignore pauses caused by crossfade internals, but allow user-paused crossfade.
            if (a !== activeAudio) return;
            if (crossfadeActive && !crossfadePaused) return;
            
            // Update state FIRST before notifying MediaSession
            state.playing = false;
            
            // Now notify MediaSession with correct state
            try { if (window.__pwaStopPositionUpdates) window.__pwaStopPositionUpdates(); } catch (e) {}
            try { if (window.__pwaUpdateMediaSession) window.__pwaUpdateMediaSession(state.currentSong); } catch (e) {}
            
            // Only show pause icon if a song is loaded
            if (state.currentSong >= 0) {
                el.playStatus.textContent = '❚❚';
            } else {
                el.playStatus.textContent = '';
            }
            el.equalizer.classList.remove('active');
            stopVisualEQ();
            stopKaraoke(); // Ferma karaoke
            requestAnimationFrame(updateTitleMarquee);
        }
        
        // Attach handlers to both audio elements
        audio.addEventListener('ended', onAudioEnded);
        audio2.addEventListener('ended', onAudioEnded);
        audio.addEventListener('play', onAudioPlay);
        audio2.addEventListener('play', onAudioPlay);
        audio.addEventListener('pause', onAudioPause);
        audio2.addEventListener('pause', onAudioPause);
        
        function fmt(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        }

        // ==================== KEYBOARD ====================
        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Enter', 'Escape', 'Backspace', 'Delete'].includes(e.key)) {
                e.preventDefault();
            }
            
            switch (e.key) {
                case 'ArrowUp': if (scroll(-1)) tickSound(); break;
                case 'ArrowDown': if (scroll(1)) tickSound(); break;
                case 'Enter': case ' ': selectSound(); handleSelect(); break;
                case 'Escape': selectSound(); goBack(); break;
                case 'Backspace':
                    selectSound();
                    if (state.view === 'keyboard') {
                        // Delete last character in keyboard view
                        state.keyboardText = state.keyboardText.slice(0, -1);
                        updateKeyboardDisplay();
                    } else {
                        goBack();
                    }
                    break;
                case 'ArrowLeft': 
                    selectSound(); 
                    if (state.view === 'keyboard') {
                        // Jump one row up (7 keys)
                        scrollKeyboard(-7);
                    } else {
                        prevTrack(); 
                    }
                    break;
                case 'ArrowRight': 
                    selectSound(); 
                    if (state.view === 'keyboard') {
                        // Jump one row down (7 keys)
                        scrollKeyboard(7);
                    } else {
                        nextTrack(); 
                    }
                    break;
                case 'Delete':
                    // Remove song from playlist if in playlist view
                    if (state.view === 'playlist' && state.playlistIdx >= 3) {
                        const position = state.playlistIdx - 3;
                        removeSongFromPlaylist(position);
                    }
                    // Remove song from queue if in queue view
                    else if (state.view === 'queue' && state.queueIdx >= 1 && state.queue.length > 0) {
                        const position = state.queueIdx - 1;
                        removeFromQueue(position);
                    }
                    break;
            }
        });

        // ==================== INIT ====================
        window.addEventListener('resize', () => requestAnimationFrame(updateTitleMarquee));
        
        // Clean up blob URLs on page unload to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            state.songs.forEach(song => {
                if (song.url && song.url.startsWith('blob:')) {
                    URL.revokeObjectURL(song.url);
                }
            });
        });

        // ==================== DIAGNOSTIC MODE (Shift + D) ====================
        let diagnosticMode = false;
        const diagEl = document.createElement('div');
        diagEl.style.cssText = 'position:fixed; top:10px; right:10px; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; font-size:10px; padding:10px; z-index:9999; display:none; pointer-events:none; white-space:pre; border-radius:6px;';
        document.body.appendChild(diagEl);

        function updateDiagnostics() {
            if (!diagnosticMode) return;

            const a = activeAudio;
            const i = inactiveAudio;
            const activeTime = a && Number.isFinite(a.currentTime) ? a.currentTime.toFixed(2) : 'N/A';
            const activeDur = a && Number.isFinite(a.duration) ? a.duration.toFixed(2) : 'N/A';
            const mem = (performance && performance.memory && performance.memory.usedJSHeapSize)
                ? (performance.memory.usedJSHeapSize / 1048576).toFixed(1) + 'MB'
                : 'N/A';

            diagEl.textContent = `
=== DIAGNOSTICS ===
View: ${state.view}
Playing: ${state.playing}
Active: ${activeTime} / ${activeDur}
Crossfade: ${crossfadeActive ? 'ACTIVE' : 'OFF'}  (session ${crossfadeSession})
Queue: ${state.queue.length}
Songs loaded: ${state.songs.length}
AudioContext: ${audioCtx ? audioCtx.state : 'N/A'}
Heap (Chrome): ${mem}
Wheel accum: ${wheel.accum.toFixed(3)}
Idx (menu/music/songs): ${state.menuIdx}/${state.musicMenuIdx}/${state.songIdx}
`.trim();

            requestAnimationFrame(updateDiagnostics);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'D' && e.shiftKey) {
                diagnosticMode = !diagnosticMode;
                diagEl.style.display = diagnosticMode ? 'block' : 'none';
                if (diagnosticMode) updateDiagnostics();
            }
        });

        console.log('[iPod] Starting initialization...');
        
        try {
            console.log('[iPod] Calling loadState...');
            loadState();
            console.log('[iPod] loadState complete');
        } catch(e) {
            console.error('[iPod] loadState error:', e);
        }
        
        try {
            console.log('[iPod] Calling applyTheme...');
            applyTheme();
            console.log('[iPod] applyTheme complete');
        } catch(e) {
            console.error('[iPod] applyTheme error:', e);
        }
        
        try {
            activeAudio.volume = state.volume;
            console.log('[iPod] Audio volume set');
        } catch(e) {
            console.error('[iPod] Audio volume error:', e);
        }
        
        console.log('[iPod] Core initialization complete!');
        
        // ==================== PWA (Service Worker v29 - Cache First) ====================
        (function () {
            if (!('serviceWorker' in navigator)) return;
            
            navigator.serviceWorker.register('./sw.js').then(reg => {
                console.log('[PWA] SW registered');
                
                reg.addEventListener('updatefound', () => {
                    const newWorker = reg.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // Nuova versione trovata: ricarica per applicare
                            console.log('[PWA] New version found, reloading...');
                            window.location.reload();
                        }
                    });
                });
            }).catch(e => {
                console.log('[PWA] SW registration failed:', e);
            });
            
            // Forza reload se il controller cambia
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('[PWA] Controller changed, reloading...');
                window.location.reload();
            });
        })();

        // ==================== PWA VISIBILITY FAILSAFE ====================
        // Ensures the iPod is visible after app loads, especially in standalone mode
        (function() {
            function ensureAppVisible() {
                const ipodEl = document.getElementById('ipod');
                const overlay = document.getElementById('portraitOnlyOverlay');
                const loadingOverlay = document.getElementById('loadingOverlay');
                
                // Force hide loading overlay after app init
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                    loadingOverlay.classList.remove('active');
                }
                
                // Ensure iPod is visible (reset any display:none)
                if (ipodEl) {
                    // Only show ipod if not in landscape mode on mobile
                    const vw = window.innerWidth || 1;
                    const vh = window.innerHeight || 1;
                    const isLandscape = vw > vh;
                    const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || 
                                        (window.matchMedia && window.matchMedia('(display-mode: fullscreen)').matches) ||
                                        !!(window.navigator && window.navigator.standalone);
                    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');
                    
                    if (isStandalone && isMobile && isLandscape) {
                        // Show portrait overlay, hide ipod
                        if (overlay) overlay.style.display = 'flex';
                        ipodEl.style.display = 'none';
                    } else {
                        // Normal mode: show ipod
                        if (overlay) overlay.style.display = 'none';
                        ipodEl.style.display = '';
                        ipodEl.style.visibility = 'visible';
                        ipodEl.style.opacity = '1';
                    }
                }
                
                console.log('[PWA] App visibility ensured');
            }
            
            // Run immediately and also after a short delay as failsafe
            if (document.readyState === 'complete') {
                ensureAppVisible();
            } else {
                window.addEventListener('load', ensureAppVisible);
            }
            // Additional failsafe: ensure visibility after 500ms
            setTimeout(ensureAppVisible, 500);
            // And again after 1.5s for slow devices
            setTimeout(ensureAppVisible, 1500);
        })();


// ===== PWA: disable pinch/double-tap zoom only when installed =====
(function() {
    try {
        const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || 
                            (window.matchMedia && window.matchMedia('(display-mode: fullscreen)').matches) ||
                            !!(window.navigator && window.navigator.standalone);
        if (!isStandalone) return;

        // Viewport is already set correctly in HTML, no need to modify

        // Prevent multi-touch (pinch) zoom
        const stopIfPinch = (e) => {
            if (e.touches && e.touches.length > 1 && e.cancelable) e.preventDefault();
        };
        document.addEventListener('touchstart', stopIfPinch, { passive: false });
        document.addEventListener('touchmove', stopIfPinch, { passive: false });

        // Prevent iOS Safari gesture events (some WKWebView contexts still emit these)
        const stopGesture = (e) => { if (e.cancelable) e.preventDefault(); };
        document.addEventListener('gesturestart', stopGesture, { passive: false });
        document.addEventListener('gesturechange', stopGesture, { passive: false });
        document.addEventListener('gestureend', stopGesture, { passive: false });

        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                if (e.cancelable) e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
    } catch (e) {}
})();

// ===== PWA Layout: fullscreen scaling + portrait-only guard =====
(function() {
    const BASE_W = 280;
    const BASE_H = 460;
    const overlay = document.getElementById('portraitOnlyOverlay');
    const ipodEl = document.getElementById('ipod');


    // Disable pinch/double-tap zoom ONLY when running as installed PWA (standalone/fullscreen).
    let _zoomGuardInited = false;
    function initZoomGuard() {
        if (_zoomGuardInited) return;
        _zoomGuardInited = true;

        const vp = document.querySelector('meta[name="viewport"]');
        if (vp) {
            vp.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
        }

        // Prevent pinch-to-zoom
        document.addEventListener('touchstart', (e) => {
            if (e.touches && e.touches.length > 1 && e.cancelable) e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.touches && e.touches.length > 1 && e.cancelable) e.preventDefault();
        }, { passive: false });

        // Prevent double-tap zoom (best-effort)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd < 300) {
                if (e.cancelable) e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
    }

    function applyPwaScale() {
        const vw = Math.max(1, window.innerWidth || 1);
        const vh = Math.max(1, window.innerHeight || 1);
        const isLandscape = vw > vh;

        // Detect if running as installed PWA
        const isStandalone = (window.matchMedia && (
            window.matchMedia('(display-mode: standalone)').matches ||
            window.matchMedia('(display-mode: fullscreen)').matches
        )) || !!(window.navigator && window.navigator.standalone);
        
        // Detect actual mobile device (not desktop browser in mobile emulation)
        const isMobileUA = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isSmallScreen = Math.min(vw, vh) < 768;
        
        // Only enforce portrait on REAL mobile devices, not desktop browsers
        // Desktop with touch (like Surface) should work in landscape
        const isRealMobile = isMobileUA && hasTouch && isSmallScreen;
        const enforcePortrait = isStandalone || isRealMobile;

        if (isStandalone) {
            initZoomGuard();
        }
        if (overlay && ipodEl) {
            if (enforcePortrait && isLandscape) {
                overlay.style.display = 'flex';
                ipodEl.style.display = 'none';
            } else {
                overlay.style.display = 'none';
                ipodEl.style.display = '';
                // Ensure visibility in standalone mode
                if (isStandalone) {
                    ipodEl.style.visibility = 'visible';
                    ipodEl.style.opacity = '1';
                }
            }
        }

        const scaleW = vw / BASE_W;
        const scaleH = vh / BASE_H;
        const scale = Math.max(0.1, Math.min(scaleW, scaleH));
        document.documentElement.style.setProperty('--pwa-scale', String(scale));
    }

    window.addEventListener('resize', applyPwaScale, { passive: true });
    window.addEventListener('orientationchange', applyPwaScale, { passive: true });
    // First paint
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', applyPwaScale, { once: true });
    } else {
        applyPwaScale();
    }

    // Device battery -> iPod battery icon (no percentages, same look)
    function initDeviceBatteryIndicator() {
        const levelEl = document.querySelector('.battery-icon .battery-level');
        if (!levelEl) return;

        // Battery Status API is available only on secure contexts and supported browsers (primarily Chromium).
        if (!window.isSecureContext || typeof navigator.getBattery !== 'function') return;

        navigator.getBattery().then((battery) => {
            const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
            const update = () => {
                const level = clamp01(battery.level);
                levelEl.style.width = Math.round(level * 100) + '%';
            };
            update();
            battery.addEventListener('levelchange', update);
            battery.addEventListener('chargingchange', update);
        }).catch(() => {});
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDeviceBatteryIndicator, { once: true });
    } else {
        initDeviceBatteryIndicator();
    }

// Best-effort orientation lock (works reliably only in installed PWA)
    function tryLockPortrait() {
        try {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(() => {});
            }
        } catch (e) {}
        window.removeEventListener('pointerdown', tryLockPortrait, true);
        window.removeEventListener('touchstart', tryLockPortrait, true);
    }
    window.addEventListener('pointerdown', tryLockPortrait, true);
    window.addEventListener('touchstart', tryLockPortrait, true);
})();

// ===== Media Session: Next/Prev controls in notification/lockscreen =====
(function() {
    if (!('mediaSession' in navigator)) return;

    let mediaSessionInited = false;
    let lastPosUpdateTs = 0;
    let positionUpdateInterval = null;

    function pickPositionAudio() {
        // During crossfade, prefer the incoming audio element so notification progress stays correct.
        try {
            if (typeof crossfadeActive !== 'undefined' && crossfadeActive && typeof crossfadeState !== 'undefined' && crossfadeState && typeof inactiveAudio !== 'undefined' && inactiveAudio) {
                if (!inactiveAudio.paused && isFinite(inactiveAudio.currentTime) && isFinite(inactiveAudio.duration) && inactiveAudio.duration > 0) {
                    return inactiveAudio;
                }
            }
        } catch (e) {}
        return activeAudio;
    }

    function updateMediaPositionState(force = false) {
        try {
            if (!navigator.mediaSession || !navigator.mediaSession.setPositionState) return;
            const a = pickPositionAudio();
            if (!a || !isFinite(a.currentTime) || !isFinite(a.duration) || a.duration <= 0) return;

            const now = performance.now();
            if (!force && (now - lastPosUpdateTs) < 750) return;
            lastPosUpdateTs = now;

            // Clamp position to valid range to prevent lockscreen glitches
            const position = Math.max(0, Math.min(a.currentTime, a.duration));
            
            // CRITICAL: Set playbackRate to 0 when paused to stop progress bar animation
            // Android uses playbackRate to animate the progress bar between updates
            const isPlaying = typeof state !== 'undefined' && state.playing;
            
            navigator.mediaSession.setPositionState({
                duration: a.duration,
                playbackRate: isPlaying ? (a.playbackRate || 1) : 0,
                position: position
            });
            
            // Also explicitly set playbackState
            navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
        } catch (e) {}
    }

    // Start periodic position updates when playing (fixes stuck progress bar)
    function startPositionUpdates() {
        stopPositionUpdates();
        positionUpdateInterval = setInterval(() => {
            try {
                if (typeof state !== 'undefined' && state.playing) {
                    updateMediaPositionState(true);
                } else {
                    stopPositionUpdates();
                }
            } catch (e) {}
        }, 1000); // Update every second
    }

    function stopPositionUpdates() {
        if (positionUpdateInterval) {
            clearInterval(positionUpdateInterval);
            positionUpdateInterval = null;
        }
    }

    function getArtworkUrl(song) {
        if (!song) return null;
        // Prefer embedded/loaded artwork if available
        if (song.artwork) return song.artwork;
        return null;
    }

    function ensureMediaSession() {
        if (mediaSessionInited) return;
        mediaSessionInited = true;

        try {
            navigator.mediaSession.setActionHandler('nexttrack', () => {
                try { nextTrack(); } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('previoustrack', () => {
                try { prevTrack(); } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('play', () => {
                try { 
                    if (!state.playing) togglePlay(); 
                    startPositionUpdates();
                } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('pause', () => {
                try { 
                    if (state.playing) togglePlay(); 
                    stopPositionUpdates();
                    updateMediaPositionState(true); // Final position update
                } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('stop', () => {
                try {
                    stopPositionUpdates();
                    if (state.playing) togglePlay();
                } catch (e) {}
            });

            // Optional: basic seek support (if the platform shows it)
            navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                try {
                    const s = (details && details.seekOffset) ? details.seekOffset : 10;
                    if (activeAudio && isFinite(activeAudio.currentTime)) {
                        activeAudio.currentTime = Math.max(0, activeAudio.currentTime - s);
                        updateMediaPositionState(true);
                    }
                } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('seekforward', (details) => {
                try {
                    const s = (details && details.seekOffset) ? details.seekOffset : 10;
                    if (activeAudio && activeAudio.duration && isFinite(activeAudio.currentTime)) {
                        activeAudio.currentTime = Math.min(activeAudio.duration, activeAudio.currentTime + s);
                        updateMediaPositionState(true);
                    }
                } catch (e) {}
            });
            navigator.mediaSession.setActionHandler('seekto', (details) => {
                try {
                    if (!details) return;
                    if (typeof details.seekTime !== 'number') return;
                    if (activeAudio && activeAudio.duration) {
                        activeAudio.currentTime = Math.max(0, Math.min(activeAudio.duration, details.seekTime));
                        updateMediaPositionState(true);
                    }
                } catch (e) {}
            });
        } catch (e) {
            // Some handlers may throw on unsupported platforms; ignore.
        }
    }

    function updateMediaMetadataForIndex(idx) {
        try {
            ensureMediaSession();
            const song = (idx >= 0 && idx < state.songs.length) ? state.songs[idx] : null;
            if (!song) return;

            const art = getArtworkUrl(song);
            const artwork = art ? [{ src: art, sizes: '512x512', type: 'image/png' }] : [];

            navigator.mediaSession.metadata = new MediaMetadata({
                title: song.title || '',
                artist: song.artist || '',
                album: song.album || '',
                artwork
            });

            // Playback state
            navigator.mediaSession.playbackState = state.playing ? 'playing' : 'paused';

            // Position state - only update if duration is valid
            updateMediaPositionState(true);
            
            // Start or stop periodic updates based on playing state
            if (state.playing) {
                startPositionUpdates();
            } else {
                stopPositionUpdates();
            }
        } catch (e) {}
    }

    // Version that only updates metadata, position will be updated by loadedmetadata event
    function updateMediaMetadataOnly(idx) {
        try {
            ensureMediaSession();
            const song = (idx >= 0 && idx < state.songs.length) ? state.songs[idx] : null;
            if (!song) return;

            const art = getArtworkUrl(song);
            const artwork = art ? [{ src: art, sizes: '512x512', type: 'image/png' }] : [];

            navigator.mediaSession.metadata = new MediaMetadata({
                title: song.title || '',
                artist: song.artist || '',
                album: song.album || '',
                artwork
            });

            // Playback state
            navigator.mediaSession.playbackState = state.playing ? 'playing' : 'paused';
            // Position will be updated by loadedmetadata/canplay events on audio elements
        } catch (e) {}
    }

    // Expose minimal hook globally so we can call it from existing code without deep refactors
    window.__pwaUpdateMediaSession = updateMediaMetadataForIndex;
    window.__pwaUpdateMediaSessionMetadataOnly = updateMediaMetadataOnly;
    window.__pwaUpdateMediaSessionPosition = updateMediaPositionState;
    window.__pwaStartPositionUpdates = startPositionUpdates;
    window.__pwaStopPositionUpdates = stopPositionUpdates;
})();

// ===== FINAL: Mark app as fully loaded =====
console.log('[iPod] All scripts executed successfully!');

// Final failsafe: ensure iPod is visible after everything loads
(function() {
    function finalVisibilityCheck() {
        var ipod = document.getElementById('ipod');
        var overlay = document.getElementById('portraitOnlyOverlay');
        var isLandscape = window.innerWidth > window.innerHeight;
        var isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (ipod) {
            // On desktop, always show iPod. On mobile, show only in portrait.
            if (!isMobile || !isLandscape) {
                ipod.style.display = '';
                ipod.style.visibility = 'visible';
                ipod.style.opacity = '1';
            }
        }
        if (overlay) {
            // Only show portrait overlay on mobile devices in landscape
            overlay.style.display = (isMobile && isLandscape) ? 'flex' : 'none';
        }
        console.log('[iPod] Final visibility check complete. isMobile:', isMobile, 'isLandscape:', isLandscape);
    }
    
    // Run after load event
    if (document.readyState === 'complete') {
        finalVisibilityCheck();
    } else {
        window.addEventListener('load', finalVisibilityCheck);
    }
    
    // Additional failsafes
    setTimeout(finalVisibilityCheck, 100);
    setTimeout(finalVisibilityCheck, 300);
    setTimeout(finalVisibilityCheck, 1000);
    setTimeout(finalVisibilityCheck, 3000);
})();
</script>
</body>
</html>
